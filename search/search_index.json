{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"install/","text":"Getting access to TruLens \u00b6 These installation instructions assume that you have conda installed and added to your path. Create a virtual environment (or modify an existing one). conda create -n \"<my_name>\" python=3.7 # Skip if using existing environment. conda activate <my_name> Install dependencies. conda install tensorflow-gpu=1 # Or whatever backend you're using. conda install keras # Or whatever backend you're using. conda install matplotlib # For visualizations. [Pip installation] Install the trulens pip package. pip install trulens [Local installation] If you would like to develop or modify trulens, you can download the source code by cloning the trulens repo. git clone https://github.com/truera/trulens.git [Locall installation] Install the trulens repo. cd trulens pip install -e .","title":"Installation"},{"location":"install/#getting-access-to-trulens","text":"These installation instructions assume that you have conda installed and added to your path. Create a virtual environment (or modify an existing one). conda create -n \"<my_name>\" python=3.7 # Skip if using existing environment. conda activate <my_name> Install dependencies. conda install tensorflow-gpu=1 # Or whatever backend you're using. conda install keras # Or whatever backend you're using. conda install matplotlib # For visualizations. [Pip installation] Install the trulens pip package. pip install trulens [Local installation] If you would like to develop or modify trulens, you can download the source code by cloning the trulens repo. git clone https://github.com/truera/trulens.git [Locall installation] Install the trulens repo. cd trulens pip install -e .","title":"Getting access to TruLens"},{"location":"quickstart/","text":"Quickstart \u00b6 Playground \u00b6 To quickly play around with the TruLens library, check out the following CoLab notebooks: PyTorch: Tensorflow 2 / Keras: Install & Use \u00b6 Check out the Installation instructions for information on how to install the library, use it, and contribute.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#playground","text":"To quickly play around with the TruLens library, check out the following CoLab notebooks: PyTorch: Tensorflow 2 / Keras:","title":"Playground"},{"location":"quickstart/#install-use","text":"Check out the Installation instructions for information on how to install the library, use it, and contribute.","title":"Install &amp; Use"},{"location":"welcome/","text":"Welcome to TruLens! \u00b6 Library containing attribution and interpretation methods for deep nets. Documentation Quick Usage \u00b6 To quickly play around with the TruLens library, check out the following CoLab notebooks: PyTorch: Tensorflow 2 / Keras: Installation \u00b6 These installation instructions assume that you have conda installed and added to your path. Create a virtual environment (or modify an existing one). conda create -n \"<my_name>\" python=3.7 # Skip if using existing environment. conda activate <my_name> Install dependencies. conda install tensorflow-gpu=1 # Or whatever backend you're using. conda install keras # Or whatever backend you're using. conda install matplotlib # For visualizations. Install the trulens package pip install trulens Overview \u00b6 Attributions \u00b6 Model Wrappers \u00b6 In order to support a wide variety of backends with different interfaces for their respective models, TruLens uses its own ModelWrapper class which provides a general model interface to simplify the implementation of the API functions. To get the model wrapper, use the get_model_wrapper method in trulens.nn.models . A model wrapper class exists for each backend that converts a model in the respective backend's format to the general TruLens ModelWrapper interface. The wrappers are found in the models module, and any model defined using Keras, Pytorch, or Tensorflow should be wrapped before being used with the other API functions that require a model -- all other TruLens functionalities expect models to be an instance of trulens.nn.models.ModelWrapper . For example, from trulens.nn.models import get_model_wrapper wrapped_model = get_model_wrapper ( model_defined_via_keras ) Attribution Methods \u00b6 Attribution methods, in the most general sense, allow us to quantify the contribution of particular variables in a model towards a particular behavior of the model. In many cases, for example, this may simply measure the effect each input variable has on the output of the network. Attribution methods extend the AttributionMethod class, and many concrete instances are found in the trulens.nn.attribution module. Once an attribution method has been instantiated, its main function is its attributions method, which returns an np.Array of batched items, where each item matches the shape of the input to the model the attribution method was instantiated with. See the method comparison demo for further information on the different types of attribution methods, their uses, and their relationships with one another. Slices, Quantities, and Distributions \u00b6 In order to obtain a high degree of flexibility in the types of attributions that can be produced, we implement Internal Influence , which is parameterized by a slice , quantity of interest , and distribution of interest , explained below. The slice essentially defines a layer to use for internal attributions. The slice for the InternalInfluence method can be specified by an instance of the Slice class in the trulens.nn.slices module. A Slice object specifies two layers: (1) the layer of the variables that we are calculating attribution for (e.g., the input layer), and (2) the layer whose output defines our quantity of interest (e.g., the output layer, see below for more on quantities of interest). The quantity of interest (QoI) essentially defines the model behavior we would like to explain using attributions. The QoI is a function of the model's output at some layer. For example, it may select the confidence score for a particular class. In its most general form, the QoI can be pecified by an implementation of the QoI class in the trulens.nn.quantities module. Several common default implementations are provided in this module as well. The distribution of interest (DoI) essentially specifies for which points surrounding each record the calculated attribution should be valid. The distribution can be specified via an implementation of the DoI class in the trulens.nn.distributions module, which is a function taking an input record and producing a list of sample input points to aggregate attribution over. A few common default distributions implementing the DoI class can be found in the trulens.nn.distributions module. See the parameterization demo for further explanations of the purpose of these parameters and examples of their usage. Visualizations \u00b6 In order to interpret the attributions produced by an AttributionMethod , a few useful visualizers are provided in the trulens.visualizations module. While the interface of each visualizer varies slightly, in general, the visualizers are a function taking an np.Array representing the attributions returned from an AttributionMethod and producing an image that can be used to interpret the attributions. Contact Us \u00b6 To communicate with other trulens developers, join our Slack ! Citation \u00b6 To cite this repository: curl -LH \"Accept: application/x-bibtex\" https://doi.org/10.5281/zenodo.4495856","title":"Welcome to TruLens!"},{"location":"welcome/#welcome-to-trulens","text":"Library containing attribution and interpretation methods for deep nets. Documentation","title":"Welcome to TruLens!"},{"location":"welcome/#quick-usage","text":"To quickly play around with the TruLens library, check out the following CoLab notebooks: PyTorch: Tensorflow 2 / Keras:","title":"Quick Usage"},{"location":"welcome/#installation","text":"These installation instructions assume that you have conda installed and added to your path. Create a virtual environment (or modify an existing one). conda create -n \"<my_name>\" python=3.7 # Skip if using existing environment. conda activate <my_name> Install dependencies. conda install tensorflow-gpu=1 # Or whatever backend you're using. conda install keras # Or whatever backend you're using. conda install matplotlib # For visualizations. Install the trulens package pip install trulens","title":"Installation"},{"location":"welcome/#overview","text":"","title":"Overview"},{"location":"welcome/#attributions","text":"","title":"Attributions"},{"location":"welcome/#model-wrappers","text":"In order to support a wide variety of backends with different interfaces for their respective models, TruLens uses its own ModelWrapper class which provides a general model interface to simplify the implementation of the API functions. To get the model wrapper, use the get_model_wrapper method in trulens.nn.models . A model wrapper class exists for each backend that converts a model in the respective backend's format to the general TruLens ModelWrapper interface. The wrappers are found in the models module, and any model defined using Keras, Pytorch, or Tensorflow should be wrapped before being used with the other API functions that require a model -- all other TruLens functionalities expect models to be an instance of trulens.nn.models.ModelWrapper . For example, from trulens.nn.models import get_model_wrapper wrapped_model = get_model_wrapper ( model_defined_via_keras )","title":"Model Wrappers"},{"location":"welcome/#attribution-methods","text":"Attribution methods, in the most general sense, allow us to quantify the contribution of particular variables in a model towards a particular behavior of the model. In many cases, for example, this may simply measure the effect each input variable has on the output of the network. Attribution methods extend the AttributionMethod class, and many concrete instances are found in the trulens.nn.attribution module. Once an attribution method has been instantiated, its main function is its attributions method, which returns an np.Array of batched items, where each item matches the shape of the input to the model the attribution method was instantiated with. See the method comparison demo for further information on the different types of attribution methods, their uses, and their relationships with one another.","title":"Attribution Methods"},{"location":"welcome/#slices-quantities-and-distributions","text":"In order to obtain a high degree of flexibility in the types of attributions that can be produced, we implement Internal Influence , which is parameterized by a slice , quantity of interest , and distribution of interest , explained below. The slice essentially defines a layer to use for internal attributions. The slice for the InternalInfluence method can be specified by an instance of the Slice class in the trulens.nn.slices module. A Slice object specifies two layers: (1) the layer of the variables that we are calculating attribution for (e.g., the input layer), and (2) the layer whose output defines our quantity of interest (e.g., the output layer, see below for more on quantities of interest). The quantity of interest (QoI) essentially defines the model behavior we would like to explain using attributions. The QoI is a function of the model's output at some layer. For example, it may select the confidence score for a particular class. In its most general form, the QoI can be pecified by an implementation of the QoI class in the trulens.nn.quantities module. Several common default implementations are provided in this module as well. The distribution of interest (DoI) essentially specifies for which points surrounding each record the calculated attribution should be valid. The distribution can be specified via an implementation of the DoI class in the trulens.nn.distributions module, which is a function taking an input record and producing a list of sample input points to aggregate attribution over. A few common default distributions implementing the DoI class can be found in the trulens.nn.distributions module. See the parameterization demo for further explanations of the purpose of these parameters and examples of their usage.","title":"Slices, Quantities, and Distributions"},{"location":"welcome/#visualizations","text":"In order to interpret the attributions produced by an AttributionMethod , a few useful visualizers are provided in the trulens.visualizations module. While the interface of each visualizer varies slightly, in general, the visualizers are a function taking an np.Array representing the attributions returned from an AttributionMethod and producing an image that can be used to interpret the attributions.","title":"Visualizations"},{"location":"welcome/#contact-us","text":"To communicate with other trulens developers, join our Slack !","title":"Contact Us"},{"location":"welcome/#citation","text":"To cite this repository: curl -LH \"Accept: application/x-bibtex\" https://doi.org/10.5281/zenodo.4495856","title":"Citation"},{"location":"api/attribution/","text":"Attribution Methods \u00b6 \u00b6 Attribution methods quantitatively measure the contribution of each of a function's individual inputs to its output. Gradient-based attribution methods compute the gradient of a model with respect to its inputs to describe how important each input is towards the output prediction. These methods can be applied to assist in explaining deep networks. TruLens provides implementations of several such techniques, found in this package. AttributionMethod \u00b6 Interface used by all attribution methods. An attribution method takes a neural network model and provides the ability to assign values to the variables of the network that specify the importance of each variable towards particular predictions. model: ModelWrapper property readonly \u00b6 Model for which attributions are calculated. __init__ ( self , model , * args , ** kwargs ) special \u00b6 Abstract constructor. Parameters: Name Type Description Default model ModelWrapper Model for which attributions are calculated. required Source code in trulens/nn/attribution.py @abstractmethod def __init__ ( self , model : ModelWrapper , * args , ** kwargs ): \"\"\" Abstract constructor. Parameters: model : Model for which attributions are calculated. \"\"\" self . _model = model attributions ( self , * model_args , ** model_kwargs ) \u00b6 Returns attributions for the given input. Attributions are in the same shape as the layer that attributions are being generated for. The numeric scale of the attributions will depend on the specific implementations of the Distribution of Interest and Quantity of Interest. However it is generally related to the scale of gradients on the Quantity of Interest. For example, Integrated Gradients uses the linear interpolation Distribution of Interest which subsumes the completeness axiom which ensures the sum of all attributions of a record equals the output determined by the Quantity of Interest on the same record. The Point Distribution of Interest will be determined by the gradient at a single point, thus being a good measure of model sensitivity. Parameters: Name Type Description Default model_args, model_kwargs The args and kwargs given to the call method of a model. This should represent the records to obtain attributions for, assumed to be a batched input. if self.model supports evaluation on data tensors , the appropriate tensor type may be used (e.g., Pytorch models may accept Pytorch tensors in addition to np.ndarray s). The shape of the inputs must match the input shape of self.model . required Returns: Type Description An array of attributions, matching the shape and type of from_cut of the slice. Each entry in the returned array represents the degree to which the corresponding feature affected the model's outcome on the corresponding point. Source code in trulens/nn/attribution.py @abstractmethod def attributions ( self , * model_args , ** model_kwargs ): \"\"\" Returns attributions for the given input. Attributions are in the same shape as the layer that attributions are being generated for. The numeric scale of the attributions will depend on the specific implementations of the Distribution of Interest and Quantity of Interest. However it is generally related to the scale of gradients on the Quantity of Interest. For example, Integrated Gradients uses the linear interpolation Distribution of Interest which subsumes the completeness axiom which ensures the sum of all attributions of a record equals the output determined by the Quantity of Interest on the same record. The Point Distribution of Interest will be determined by the gradient at a single point, thus being a good measure of model sensitivity. Parameters: model_args, model_kwargs: The args and kwargs given to the call method of a model. This should represent the records to obtain attributions for, assumed to be a *batched* input. if `self.model` supports evaluation on *data tensors*, the appropriate tensor type may be used (e.g., Pytorch models may accept Pytorch tensors in addition to `np.ndarray`s). The shape of the inputs must match the input shape of `self.model`. Returns: An array of attributions, matching the shape and type of `from_cut` of the slice. Each entry in the returned array represents the degree to which the corresponding feature affected the model's outcome on the corresponding point. \"\"\" raise NotImplementedError InputAttribution \u00b6 Attributions of input features on either internal or output quantities. This is essentially an alias for InternalInfluence ( model , ( trulens . nn . slices . InputCut (), cut ), qoi , doi , multiply_activation ) __init__ ( self , model , cut = None , qoi = 'max' , doi = 'point' , multiply_activation = True ) special \u00b6 Parameters: Name Type Description Default model ModelWrapper Model for which attributions are calculated. required cut Optional[Union[trulens.nn.slices.Cut, int, str]] The cut determining the layer from which the QoI is derived. Expects a Cut object, or a related type that can be interpreted as a Cut , as documented below. If an int is given, it represents the index of a layer in model . If a str is given, it represents the name of a layer in model . None is an alternative for slices.OutputCut() . None qoi Union[trulens.nn.quantities.QoI, int, Tuple[int], Callable, str] quantities.QoI | int | tuple | str Quantity of interest to attribute. Expects a QoI object, or a related type that can be interpreted as a QoI , as documented below. If an int is given, the quantity of interest is taken to be the slice output for the class/neuron/channel specified by the given integer, i.e., quantities . InternalChannelQoI ( qoi ) If a tuple or list of two integers is given, then the quantity of interest is taken to be the comparative quantity for the class given by the first integer against the class given by the second integer, i.e., quantities . ComparativeQoI ( * qoi ) If a callable is given, it is interpreted as a function representing the QoI, i.e., quantities . LambdaQoI ( qoi ) If the string, 'max' , is given, the quantity of interest is taken to be the output for the class with the maximum score, i.e., quantities . MaxClassQoI () 'max' doi Union[trulens.nn.distributions.DoI, str] distributions.DoI | str Distribution of interest over inputs. Expects a DoI object, or a related type that can be interpreted as a DoI , as documented below. If the string, 'point' , is given, the distribution is taken to be the single point passed to attributions , i.e., distributions . PointDoi () If the string, 'linear' , is given, the distribution is taken to be the linear interpolation from the zero input to the point passed to attributions , i.e., distributions . LinearDoi () 'point' multiply_activation bool bool, optional Whether to multiply the gradient result by its corresponding activation, thus converting from \" influence space \" to \" attribution space .\" True Source code in trulens/nn/attribution.py def __init__ ( self , model : ModelWrapper , cut : CutLike = None , qoi : QoiLike = 'max' , doi : DoiLike = 'point' , multiply_activation : bool = True ): \"\"\" Parameters: model : Model for which attributions are calculated. cut : The cut determining the layer from which the QoI is derived. Expects a `Cut` object, or a related type that can be interpreted as a `Cut`, as documented below. If an `int` is given, it represents the index of a layer in `model`. If a `str` is given, it represents the name of a layer in `model`. `None` is an alternative for `slices.OutputCut()`. qoi : quantities.QoI | int | tuple | str Quantity of interest to attribute. Expects a `QoI` object, or a related type that can be interpreted as a `QoI`, as documented below. If an `int` is given, the quantity of interest is taken to be the slice output for the class/neuron/channel specified by the given integer, i.e., ```python quantities.InternalChannelQoI(qoi) ``` If a tuple or list of two integers is given, then the quantity of interest is taken to be the comparative quantity for the class given by the first integer against the class given by the second integer, i.e., ```python quantities.ComparativeQoI(*qoi) ``` If a callable is given, it is interpreted as a function representing the QoI, i.e., ```python quantities.LambdaQoI(qoi) ``` If the string, `'max'`, is given, the quantity of interest is taken to be the output for the class with the maximum score, i.e., ```python quantities.MaxClassQoI() ``` doi : distributions.DoI | str Distribution of interest over inputs. Expects a `DoI` object, or a related type that can be interpreted as a `DoI`, as documented below. If the string, `'point'`, is given, the distribution is taken to be the single point passed to `attributions`, i.e., ```python distributions.PointDoi() ``` If the string, `'linear'`, is given, the distribution is taken to be the linear interpolation from the zero input to the point passed to `attributions`, i.e., ```python distributions.LinearDoi() ``` multiply_activation : bool, optional Whether to multiply the gradient result by its corresponding activation, thus converting from \"*influence space*\" to \"*attribution space*.\" \"\"\" super () . __init__ ( model , ( InputCut (), cut ), qoi , doi , multiply_activation = multiply_activation ) IntegratedGradients \u00b6 Implementation for the Integrated Gradients method from the following paper: Axiomatic Attribution for Deep Networks This should be cited using: @INPROCEEDINGS { sundararajan17axiomatic , author = {Mukund Sundararajan and Ankur Taly, and Qiqi Yan} , title = {Axiomatic Attribution for Deep Networks} , booktitle = {International Conference on Machine Learning (ICML)} , year = {2017} , } This is essentially an alias for InternalInfluence ( model , ( trulens . nn . slices . InputCut (), trulens . nn . slices . OutputCut ()), 'max' , trulens . nn . distributions . LinearDoi ( baseline , resolution ), multiply_activation = True ) __init__ ( self , model , baseline = None , resolution = 50 ) special \u00b6 Parameters: Name Type Description Default model ModelWrapper Model for which attributions are calculated. required baseline The baseline to interpolate from. Must be same shape as the input. If None is given, the zero vector in the appropriate shape will be used. None resolution int Number of points to use in the approximation. A higher resolution is more computationally expensive, but gives a better approximation of the mathematical formula this attribution method represents. 50 Source code in trulens/nn/attribution.py def __init__ ( self , model : ModelWrapper , baseline = None , resolution : int = 50 ): \"\"\" Parameters: model: Model for which attributions are calculated. baseline: The baseline to interpolate from. Must be same shape as the input. If `None` is given, the zero vector in the appropriate shape will be used. resolution: Number of points to use in the approximation. A higher resolution is more computationally expensive, but gives a better approximation of the mathematical formula this attribution method represents. \"\"\" super () . __init__ ( model , OutputCut (), 'max' , LinearDoi ( baseline , resolution ), multiply_activation = True ) InternalInfluence \u00b6 Internal attributions parameterized by a slice, quantity of interest, and distribution of interest. The slice specifies the layers at which the internals of the model are to be exposed; it is represented by two cuts , which specify the layer the attributions are assigned to and the layer from which the quantity of interest is derived. The Quantity of Interest (QoI) is a function of the output specified by the slice that determines the network output behavior that the attributions are to describe. The Distribution of Interest (DoI) specifies the records over which the attributions are aggregated. More information can be found in the following paper: Influence-Directed Explanations for Deep Convolutional Networks This should be cited using: @INPROCEEDINGS { leino18influence , author = { Klas Leino and Shayak Sen and Anupam Datta and Matt Fredrikson and Linyi Li} , title = { Influence-Directed Explanations for Deep Convolutional Networks} , booktitle = {IEEE International Test Conference (ITC)} , year = {2018} , } __init__ ( self , model , cuts , qoi , doi , multiply_activation = True ) special \u00b6 Parameters: Name Type Description Default model ModelWrapper Model for which attributions are calculated. required cuts Optional[Union[trulens.nn.slices.Slice, Tuple[Union[trulens.nn.slices.Cut, int, str, NoneType]], trulens.nn.slices.Cut, int, str]] The slice to use when computing the attributions. The slice keeps track of the layer whose output attributions are calculated and the layer for which the quantity of interest is computed. Expects a Slice object, or a related type that can be interpreted as a Slice , as documented below. If a single Cut object is given, it is assumed to be the cut representing the layer for which attributions are calculated (i.e., from_cut in Slice ) and the layer for the quantity of interest (i.e., to_cut in slices.Slice ) is taken to be the output of the network. If a tuple or list of two Cut s is given, they are assumed to be from_cut and to_cut , respectively. A cut (or the cuts within the tuple) can also be represented as an int , str , or None . If an int is given, it represents the index of a layer in model . If a str is given, it represents the name of a layer in model . None is an alternative for slices.InputCut . required qoi Union[trulens.nn.quantities.QoI, int, Tuple[int], Callable, str] Quantity of interest to attribute. Expects a QoI object, or a related type that can be interpreted as a QoI , as documented below. If an int is given, the quantity of interest is taken to be the slice output for the class/neuron/channel specified by the given integer, i.e., quantities . InternalChannelQoI ( qoi ) If a tuple or list of two integers is given, then the quantity of interest is taken to be the comparative quantity for the class given by the first integer against the class given by the second integer, i.e., quantities . ComparativeQoI ( * qoi ) If a callable is given, it is interpreted as a function representing the QoI, i.e., quantities . LambdaQoI ( qoi ) If the string, 'max' , is given, the quantity of interest is taken to be the output for the class with the maximum score, i.e., quantities . MaxClassQoI () required doi Union[trulens.nn.distributions.DoI, str] Distribution of interest over inputs. Expects a DoI object, or a related type that can be interpreted as a DoI , as documented below. If the string, 'point' , is given, the distribution is taken to be the single point passed to attributions , i.e., distributions . PointDoi () If the string, 'linear' , is given, the distribution is taken to be the linear interpolation from the zero input to the point passed to attributions , i.e., distributions . LinearDoi () required multiply_activation bool Whether to multiply the gradient result by its corresponding activation, thus converting from \" influence space \" to \" attribution space .\" True Source code in trulens/nn/attribution.py def __init__ ( self , model : ModelWrapper , cuts : SliceLike , qoi : QoiLike , doi : DoiLike , multiply_activation : bool = True ): \"\"\" Parameters: model: Model for which attributions are calculated. cuts: The slice to use when computing the attributions. The slice keeps track of the layer whose output attributions are calculated and the layer for which the quantity of interest is computed. Expects a `Slice` object, or a related type that can be interpreted as a `Slice`, as documented below. If a single `Cut` object is given, it is assumed to be the cut representing the layer for which attributions are calculated (i.e., `from_cut` in `Slice`) and the layer for the quantity of interest (i.e., `to_cut` in `slices.Slice`) is taken to be the output of the network. If a tuple or list of two `Cut`s is given, they are assumed to be `from_cut` and `to_cut`, respectively. A cut (or the cuts within the tuple) can also be represented as an `int`, `str`, or `None`. If an `int` is given, it represents the index of a layer in `model`. If a `str` is given, it represents the name of a layer in `model`. `None` is an alternative for `slices.InputCut`. qoi: Quantity of interest to attribute. Expects a `QoI` object, or a related type that can be interpreted as a `QoI`, as documented below. If an `int` is given, the quantity of interest is taken to be the slice output for the class/neuron/channel specified by the given integer, i.e., ```python quantities.InternalChannelQoI(qoi) ``` If a tuple or list of two integers is given, then the quantity of interest is taken to be the comparative quantity for the class given by the first integer against the class given by the second integer, i.e., ```python quantities.ComparativeQoI(*qoi) ``` If a callable is given, it is interpreted as a function representing the QoI, i.e., ```python quantities.LambdaQoI(qoi) ``` If the string, `'max'`, is given, the quantity of interest is taken to be the output for the class with the maximum score, i.e., ```python quantities.MaxClassQoI() ``` doi: Distribution of interest over inputs. Expects a `DoI` object, or a related type that can be interpreted as a `DoI`, as documented below. If the string, `'point'`, is given, the distribution is taken to be the single point passed to `attributions`, i.e., ```python distributions.PointDoi() ``` If the string, `'linear'`, is given, the distribution is taken to be the linear interpolation from the zero input to the point passed to `attributions`, i.e., ```python distributions.LinearDoi() ``` multiply_activation: Whether to multiply the gradient result by its corresponding activation, thus converting from \"*influence space*\" to \"*attribution space*.\" \"\"\" super () . __init__ ( model ) self . slice = InternalInfluence . __get_slice ( cuts ) self . qoi = InternalInfluence . __get_qoi ( qoi ) self . doi = InternalInfluence . __get_doi ( doi ) self . _do_multiply = multiply_activation attributions ( self , * model_args , ** model_kwargs ) \u00b6 Returns attributions for the given input. Attributions are in the same shape as the layer that attributions are being generated for. The numeric scale of the attributions will depend on the specific implementations of the Distribution of Interest and Quantity of Interest. However it is generally related to the scale of gradients on the Quantity of Interest. For example, Integrated Gradients uses the linear interpolation Distribution of Interest which subsumes the completeness axiom which ensures the sum of all attributions of a record equals the output determined by the Quantity of Interest on the same record. The Point Distribution of Interest will be determined by the gradient at a single point, thus being a good measure of model sensitivity. Parameters: Name Type Description Default model_args, model_kwargs The args and kwargs given to the call method of a model. This should represent the records to obtain attributions for, assumed to be a batched input. if self.model supports evaluation on data tensors , the appropriate tensor type may be used (e.g., Pytorch models may accept Pytorch tensors in addition to np.ndarray s). The shape of the inputs must match the input shape of self.model . required Returns: Type Description An array of attributions, matching the shape and type of from_cut of the slice. Each entry in the returned array represents the degree to which the corresponding feature affected the model's outcome on the corresponding point. Source code in trulens/nn/attribution.py def attributions ( self , * model_args , ** model_kwargs ): doi_cut = self . doi . cut () if self . doi . cut () else InputCut () doi_val = self . model . fprop ( model_args , model_kwargs , to_cut = doi_cut ) # DoI supports tensor or list of tensor. unwrap args to perform DoI on # top level list # Depending on the model_arg input, the data may be nested in data # containers. We unwrap so that there operations are working on a single # level of data container. if isinstance ( doi_val , DATA_CONTAINER_TYPE ) and isinstance ( doi_val [ 0 ], DATA_CONTAINER_TYPE ): doi_val = doi_val [ 0 ] if isinstance ( doi_val , DATA_CONTAINER_TYPE ) and len ( doi_val ) == 1 : doi_val = doi_val [ 0 ] D = self . doi ( doi_val ) n_doi = len ( D ) D = InternalInfluence . __concatenate_doi ( D ) # Calculate the gradient of each of the points in the DoI. qoi_grads = self . model . qoi_bprop ( self . qoi , model_args , model_kwargs , attribution_cut = self . slice . from_cut , to_cut = self . slice . to_cut , intervention = D , doi_cut = doi_cut ) # Take the mean across the samples in the DoI. if isinstance ( qoi_grads , DATA_CONTAINER_TYPE ): attributions = [ get_backend () . mean ( get_backend () . reshape ( qoi_grad , ( n_doi , - 1 ) + qoi_grad . shape [ 1 :]), axis = 0 ) for qoi_grad in qoi_grads ] else : attributions = get_backend () . mean ( get_backend () . reshape ( qoi_grads , ( n_doi , - 1 ) + qoi_grads . shape [ 1 :]), axis = 0 ) # Multiply by the activation multiplier if specified. if self . _do_multiply : z_val = self . model . fprop ( model_args , model_kwargs , to_cut = self . slice . from_cut ) if isinstance ( z_val , DATA_CONTAINER_TYPE ) and len ( z_val ) == 1 : z_val = z_val [ 0 ] if isinstance ( attributions , DATA_CONTAINER_TYPE ): for i in range ( len ( attributions )): if isinstance ( z_val , DATA_CONTAINER_TYPE ) and len ( z_val ) == len ( attributions ): attributions [ i ] *= self . doi . get_activation_multiplier ( z_val [ i ]) else : attributions [ i ] *= ( self . doi . get_activation_multiplier ( z_val )) else : attributions *= self . doi . get_activation_multiplier ( z_val ) return attributions","title":"Attribution"},{"location":"api/attribution/#attribution-methods","text":"","title":"Attribution Methods"},{"location":"api/attribution/#trulens.nn.attribution","text":"Attribution methods quantitatively measure the contribution of each of a function's individual inputs to its output. Gradient-based attribution methods compute the gradient of a model with respect to its inputs to describe how important each input is towards the output prediction. These methods can be applied to assist in explaining deep networks. TruLens provides implementations of several such techniques, found in this package.","title":"trulens.nn.attribution"},{"location":"api/attribution/#trulens.nn.attribution.AttributionMethod","text":"Interface used by all attribution methods. An attribution method takes a neural network model and provides the ability to assign values to the variables of the network that specify the importance of each variable towards particular predictions.","title":"AttributionMethod"},{"location":"api/attribution/#trulens.nn.attribution.AttributionMethod.model","text":"Model for which attributions are calculated.","title":"model"},{"location":"api/attribution/#trulens.nn.attribution.AttributionMethod.__init__","text":"Abstract constructor. Parameters: Name Type Description Default model ModelWrapper Model for which attributions are calculated. required Source code in trulens/nn/attribution.py @abstractmethod def __init__ ( self , model : ModelWrapper , * args , ** kwargs ): \"\"\" Abstract constructor. Parameters: model : Model for which attributions are calculated. \"\"\" self . _model = model","title":"__init__()"},{"location":"api/attribution/#trulens.nn.attribution.AttributionMethod.attributions","text":"Returns attributions for the given input. Attributions are in the same shape as the layer that attributions are being generated for. The numeric scale of the attributions will depend on the specific implementations of the Distribution of Interest and Quantity of Interest. However it is generally related to the scale of gradients on the Quantity of Interest. For example, Integrated Gradients uses the linear interpolation Distribution of Interest which subsumes the completeness axiom which ensures the sum of all attributions of a record equals the output determined by the Quantity of Interest on the same record. The Point Distribution of Interest will be determined by the gradient at a single point, thus being a good measure of model sensitivity. Parameters: Name Type Description Default model_args, model_kwargs The args and kwargs given to the call method of a model. This should represent the records to obtain attributions for, assumed to be a batched input. if self.model supports evaluation on data tensors , the appropriate tensor type may be used (e.g., Pytorch models may accept Pytorch tensors in addition to np.ndarray s). The shape of the inputs must match the input shape of self.model . required Returns: Type Description An array of attributions, matching the shape and type of from_cut of the slice. Each entry in the returned array represents the degree to which the corresponding feature affected the model's outcome on the corresponding point. Source code in trulens/nn/attribution.py @abstractmethod def attributions ( self , * model_args , ** model_kwargs ): \"\"\" Returns attributions for the given input. Attributions are in the same shape as the layer that attributions are being generated for. The numeric scale of the attributions will depend on the specific implementations of the Distribution of Interest and Quantity of Interest. However it is generally related to the scale of gradients on the Quantity of Interest. For example, Integrated Gradients uses the linear interpolation Distribution of Interest which subsumes the completeness axiom which ensures the sum of all attributions of a record equals the output determined by the Quantity of Interest on the same record. The Point Distribution of Interest will be determined by the gradient at a single point, thus being a good measure of model sensitivity. Parameters: model_args, model_kwargs: The args and kwargs given to the call method of a model. This should represent the records to obtain attributions for, assumed to be a *batched* input. if `self.model` supports evaluation on *data tensors*, the appropriate tensor type may be used (e.g., Pytorch models may accept Pytorch tensors in addition to `np.ndarray`s). The shape of the inputs must match the input shape of `self.model`. Returns: An array of attributions, matching the shape and type of `from_cut` of the slice. Each entry in the returned array represents the degree to which the corresponding feature affected the model's outcome on the corresponding point. \"\"\" raise NotImplementedError","title":"attributions()"},{"location":"api/attribution/#trulens.nn.attribution.InputAttribution","text":"Attributions of input features on either internal or output quantities. This is essentially an alias for InternalInfluence ( model , ( trulens . nn . slices . InputCut (), cut ), qoi , doi , multiply_activation )","title":"InputAttribution"},{"location":"api/attribution/#trulens.nn.attribution.InputAttribution.__init__","text":"Parameters: Name Type Description Default model ModelWrapper Model for which attributions are calculated. required cut Optional[Union[trulens.nn.slices.Cut, int, str]] The cut determining the layer from which the QoI is derived. Expects a Cut object, or a related type that can be interpreted as a Cut , as documented below. If an int is given, it represents the index of a layer in model . If a str is given, it represents the name of a layer in model . None is an alternative for slices.OutputCut() . None qoi Union[trulens.nn.quantities.QoI, int, Tuple[int], Callable, str] quantities.QoI | int | tuple | str Quantity of interest to attribute. Expects a QoI object, or a related type that can be interpreted as a QoI , as documented below. If an int is given, the quantity of interest is taken to be the slice output for the class/neuron/channel specified by the given integer, i.e., quantities . InternalChannelQoI ( qoi ) If a tuple or list of two integers is given, then the quantity of interest is taken to be the comparative quantity for the class given by the first integer against the class given by the second integer, i.e., quantities . ComparativeQoI ( * qoi ) If a callable is given, it is interpreted as a function representing the QoI, i.e., quantities . LambdaQoI ( qoi ) If the string, 'max' , is given, the quantity of interest is taken to be the output for the class with the maximum score, i.e., quantities . MaxClassQoI () 'max' doi Union[trulens.nn.distributions.DoI, str] distributions.DoI | str Distribution of interest over inputs. Expects a DoI object, or a related type that can be interpreted as a DoI , as documented below. If the string, 'point' , is given, the distribution is taken to be the single point passed to attributions , i.e., distributions . PointDoi () If the string, 'linear' , is given, the distribution is taken to be the linear interpolation from the zero input to the point passed to attributions , i.e., distributions . LinearDoi () 'point' multiply_activation bool bool, optional Whether to multiply the gradient result by its corresponding activation, thus converting from \" influence space \" to \" attribution space .\" True Source code in trulens/nn/attribution.py def __init__ ( self , model : ModelWrapper , cut : CutLike = None , qoi : QoiLike = 'max' , doi : DoiLike = 'point' , multiply_activation : bool = True ): \"\"\" Parameters: model : Model for which attributions are calculated. cut : The cut determining the layer from which the QoI is derived. Expects a `Cut` object, or a related type that can be interpreted as a `Cut`, as documented below. If an `int` is given, it represents the index of a layer in `model`. If a `str` is given, it represents the name of a layer in `model`. `None` is an alternative for `slices.OutputCut()`. qoi : quantities.QoI | int | tuple | str Quantity of interest to attribute. Expects a `QoI` object, or a related type that can be interpreted as a `QoI`, as documented below. If an `int` is given, the quantity of interest is taken to be the slice output for the class/neuron/channel specified by the given integer, i.e., ```python quantities.InternalChannelQoI(qoi) ``` If a tuple or list of two integers is given, then the quantity of interest is taken to be the comparative quantity for the class given by the first integer against the class given by the second integer, i.e., ```python quantities.ComparativeQoI(*qoi) ``` If a callable is given, it is interpreted as a function representing the QoI, i.e., ```python quantities.LambdaQoI(qoi) ``` If the string, `'max'`, is given, the quantity of interest is taken to be the output for the class with the maximum score, i.e., ```python quantities.MaxClassQoI() ``` doi : distributions.DoI | str Distribution of interest over inputs. Expects a `DoI` object, or a related type that can be interpreted as a `DoI`, as documented below. If the string, `'point'`, is given, the distribution is taken to be the single point passed to `attributions`, i.e., ```python distributions.PointDoi() ``` If the string, `'linear'`, is given, the distribution is taken to be the linear interpolation from the zero input to the point passed to `attributions`, i.e., ```python distributions.LinearDoi() ``` multiply_activation : bool, optional Whether to multiply the gradient result by its corresponding activation, thus converting from \"*influence space*\" to \"*attribution space*.\" \"\"\" super () . __init__ ( model , ( InputCut (), cut ), qoi , doi , multiply_activation = multiply_activation )","title":"__init__()"},{"location":"api/attribution/#trulens.nn.attribution.IntegratedGradients","text":"Implementation for the Integrated Gradients method from the following paper: Axiomatic Attribution for Deep Networks This should be cited using: @INPROCEEDINGS { sundararajan17axiomatic , author = {Mukund Sundararajan and Ankur Taly, and Qiqi Yan} , title = {Axiomatic Attribution for Deep Networks} , booktitle = {International Conference on Machine Learning (ICML)} , year = {2017} , } This is essentially an alias for InternalInfluence ( model , ( trulens . nn . slices . InputCut (), trulens . nn . slices . OutputCut ()), 'max' , trulens . nn . distributions . LinearDoi ( baseline , resolution ), multiply_activation = True )","title":"IntegratedGradients"},{"location":"api/attribution/#trulens.nn.attribution.IntegratedGradients.__init__","text":"Parameters: Name Type Description Default model ModelWrapper Model for which attributions are calculated. required baseline The baseline to interpolate from. Must be same shape as the input. If None is given, the zero vector in the appropriate shape will be used. None resolution int Number of points to use in the approximation. A higher resolution is more computationally expensive, but gives a better approximation of the mathematical formula this attribution method represents. 50 Source code in trulens/nn/attribution.py def __init__ ( self , model : ModelWrapper , baseline = None , resolution : int = 50 ): \"\"\" Parameters: model: Model for which attributions are calculated. baseline: The baseline to interpolate from. Must be same shape as the input. If `None` is given, the zero vector in the appropriate shape will be used. resolution: Number of points to use in the approximation. A higher resolution is more computationally expensive, but gives a better approximation of the mathematical formula this attribution method represents. \"\"\" super () . __init__ ( model , OutputCut (), 'max' , LinearDoi ( baseline , resolution ), multiply_activation = True )","title":"__init__()"},{"location":"api/attribution/#trulens.nn.attribution.InternalInfluence","text":"Internal attributions parameterized by a slice, quantity of interest, and distribution of interest. The slice specifies the layers at which the internals of the model are to be exposed; it is represented by two cuts , which specify the layer the attributions are assigned to and the layer from which the quantity of interest is derived. The Quantity of Interest (QoI) is a function of the output specified by the slice that determines the network output behavior that the attributions are to describe. The Distribution of Interest (DoI) specifies the records over which the attributions are aggregated. More information can be found in the following paper: Influence-Directed Explanations for Deep Convolutional Networks This should be cited using: @INPROCEEDINGS { leino18influence , author = { Klas Leino and Shayak Sen and Anupam Datta and Matt Fredrikson and Linyi Li} , title = { Influence-Directed Explanations for Deep Convolutional Networks} , booktitle = {IEEE International Test Conference (ITC)} , year = {2018} , }","title":"InternalInfluence"},{"location":"api/attribution/#trulens.nn.attribution.InternalInfluence.__init__","text":"Parameters: Name Type Description Default model ModelWrapper Model for which attributions are calculated. required cuts Optional[Union[trulens.nn.slices.Slice, Tuple[Union[trulens.nn.slices.Cut, int, str, NoneType]], trulens.nn.slices.Cut, int, str]] The slice to use when computing the attributions. The slice keeps track of the layer whose output attributions are calculated and the layer for which the quantity of interest is computed. Expects a Slice object, or a related type that can be interpreted as a Slice , as documented below. If a single Cut object is given, it is assumed to be the cut representing the layer for which attributions are calculated (i.e., from_cut in Slice ) and the layer for the quantity of interest (i.e., to_cut in slices.Slice ) is taken to be the output of the network. If a tuple or list of two Cut s is given, they are assumed to be from_cut and to_cut , respectively. A cut (or the cuts within the tuple) can also be represented as an int , str , or None . If an int is given, it represents the index of a layer in model . If a str is given, it represents the name of a layer in model . None is an alternative for slices.InputCut . required qoi Union[trulens.nn.quantities.QoI, int, Tuple[int], Callable, str] Quantity of interest to attribute. Expects a QoI object, or a related type that can be interpreted as a QoI , as documented below. If an int is given, the quantity of interest is taken to be the slice output for the class/neuron/channel specified by the given integer, i.e., quantities . InternalChannelQoI ( qoi ) If a tuple or list of two integers is given, then the quantity of interest is taken to be the comparative quantity for the class given by the first integer against the class given by the second integer, i.e., quantities . ComparativeQoI ( * qoi ) If a callable is given, it is interpreted as a function representing the QoI, i.e., quantities . LambdaQoI ( qoi ) If the string, 'max' , is given, the quantity of interest is taken to be the output for the class with the maximum score, i.e., quantities . MaxClassQoI () required doi Union[trulens.nn.distributions.DoI, str] Distribution of interest over inputs. Expects a DoI object, or a related type that can be interpreted as a DoI , as documented below. If the string, 'point' , is given, the distribution is taken to be the single point passed to attributions , i.e., distributions . PointDoi () If the string, 'linear' , is given, the distribution is taken to be the linear interpolation from the zero input to the point passed to attributions , i.e., distributions . LinearDoi () required multiply_activation bool Whether to multiply the gradient result by its corresponding activation, thus converting from \" influence space \" to \" attribution space .\" True Source code in trulens/nn/attribution.py def __init__ ( self , model : ModelWrapper , cuts : SliceLike , qoi : QoiLike , doi : DoiLike , multiply_activation : bool = True ): \"\"\" Parameters: model: Model for which attributions are calculated. cuts: The slice to use when computing the attributions. The slice keeps track of the layer whose output attributions are calculated and the layer for which the quantity of interest is computed. Expects a `Slice` object, or a related type that can be interpreted as a `Slice`, as documented below. If a single `Cut` object is given, it is assumed to be the cut representing the layer for which attributions are calculated (i.e., `from_cut` in `Slice`) and the layer for the quantity of interest (i.e., `to_cut` in `slices.Slice`) is taken to be the output of the network. If a tuple or list of two `Cut`s is given, they are assumed to be `from_cut` and `to_cut`, respectively. A cut (or the cuts within the tuple) can also be represented as an `int`, `str`, or `None`. If an `int` is given, it represents the index of a layer in `model`. If a `str` is given, it represents the name of a layer in `model`. `None` is an alternative for `slices.InputCut`. qoi: Quantity of interest to attribute. Expects a `QoI` object, or a related type that can be interpreted as a `QoI`, as documented below. If an `int` is given, the quantity of interest is taken to be the slice output for the class/neuron/channel specified by the given integer, i.e., ```python quantities.InternalChannelQoI(qoi) ``` If a tuple or list of two integers is given, then the quantity of interest is taken to be the comparative quantity for the class given by the first integer against the class given by the second integer, i.e., ```python quantities.ComparativeQoI(*qoi) ``` If a callable is given, it is interpreted as a function representing the QoI, i.e., ```python quantities.LambdaQoI(qoi) ``` If the string, `'max'`, is given, the quantity of interest is taken to be the output for the class with the maximum score, i.e., ```python quantities.MaxClassQoI() ``` doi: Distribution of interest over inputs. Expects a `DoI` object, or a related type that can be interpreted as a `DoI`, as documented below. If the string, `'point'`, is given, the distribution is taken to be the single point passed to `attributions`, i.e., ```python distributions.PointDoi() ``` If the string, `'linear'`, is given, the distribution is taken to be the linear interpolation from the zero input to the point passed to `attributions`, i.e., ```python distributions.LinearDoi() ``` multiply_activation: Whether to multiply the gradient result by its corresponding activation, thus converting from \"*influence space*\" to \"*attribution space*.\" \"\"\" super () . __init__ ( model ) self . slice = InternalInfluence . __get_slice ( cuts ) self . qoi = InternalInfluence . __get_qoi ( qoi ) self . doi = InternalInfluence . __get_doi ( doi ) self . _do_multiply = multiply_activation","title":"__init__()"},{"location":"api/attribution/#trulens.nn.attribution.InternalInfluence.attributions","text":"Returns attributions for the given input. Attributions are in the same shape as the layer that attributions are being generated for. The numeric scale of the attributions will depend on the specific implementations of the Distribution of Interest and Quantity of Interest. However it is generally related to the scale of gradients on the Quantity of Interest. For example, Integrated Gradients uses the linear interpolation Distribution of Interest which subsumes the completeness axiom which ensures the sum of all attributions of a record equals the output determined by the Quantity of Interest on the same record. The Point Distribution of Interest will be determined by the gradient at a single point, thus being a good measure of model sensitivity. Parameters: Name Type Description Default model_args, model_kwargs The args and kwargs given to the call method of a model. This should represent the records to obtain attributions for, assumed to be a batched input. if self.model supports evaluation on data tensors , the appropriate tensor type may be used (e.g., Pytorch models may accept Pytorch tensors in addition to np.ndarray s). The shape of the inputs must match the input shape of self.model . required Returns: Type Description An array of attributions, matching the shape and type of from_cut of the slice. Each entry in the returned array represents the degree to which the corresponding feature affected the model's outcome on the corresponding point. Source code in trulens/nn/attribution.py def attributions ( self , * model_args , ** model_kwargs ): doi_cut = self . doi . cut () if self . doi . cut () else InputCut () doi_val = self . model . fprop ( model_args , model_kwargs , to_cut = doi_cut ) # DoI supports tensor or list of tensor. unwrap args to perform DoI on # top level list # Depending on the model_arg input, the data may be nested in data # containers. We unwrap so that there operations are working on a single # level of data container. if isinstance ( doi_val , DATA_CONTAINER_TYPE ) and isinstance ( doi_val [ 0 ], DATA_CONTAINER_TYPE ): doi_val = doi_val [ 0 ] if isinstance ( doi_val , DATA_CONTAINER_TYPE ) and len ( doi_val ) == 1 : doi_val = doi_val [ 0 ] D = self . doi ( doi_val ) n_doi = len ( D ) D = InternalInfluence . __concatenate_doi ( D ) # Calculate the gradient of each of the points in the DoI. qoi_grads = self . model . qoi_bprop ( self . qoi , model_args , model_kwargs , attribution_cut = self . slice . from_cut , to_cut = self . slice . to_cut , intervention = D , doi_cut = doi_cut ) # Take the mean across the samples in the DoI. if isinstance ( qoi_grads , DATA_CONTAINER_TYPE ): attributions = [ get_backend () . mean ( get_backend () . reshape ( qoi_grad , ( n_doi , - 1 ) + qoi_grad . shape [ 1 :]), axis = 0 ) for qoi_grad in qoi_grads ] else : attributions = get_backend () . mean ( get_backend () . reshape ( qoi_grads , ( n_doi , - 1 ) + qoi_grads . shape [ 1 :]), axis = 0 ) # Multiply by the activation multiplier if specified. if self . _do_multiply : z_val = self . model . fprop ( model_args , model_kwargs , to_cut = self . slice . from_cut ) if isinstance ( z_val , DATA_CONTAINER_TYPE ) and len ( z_val ) == 1 : z_val = z_val [ 0 ] if isinstance ( attributions , DATA_CONTAINER_TYPE ): for i in range ( len ( attributions )): if isinstance ( z_val , DATA_CONTAINER_TYPE ) and len ( z_val ) == len ( attributions ): attributions [ i ] *= self . doi . get_activation_multiplier ( z_val [ i ]) else : attributions [ i ] *= ( self . doi . get_activation_multiplier ( z_val )) else : attributions *= self . doi . get_activation_multiplier ( z_val ) return attributions","title":"attributions()"},{"location":"api/distributions/","text":"Distributions of Interest \u00b6 \u00b6 The distribution of interest lets us specify the set of samples over which we want our explanations to be faithful. In some cases, we may want to explain the model\u2019s behavior on a particular record, whereas other times we may be interested in a more general behavior over a distribution of samples. DoI \u00b6 Interface for distributions of interest. The Distribution of Interest (DoI) specifies the samples over which an attribution method is aggregated. __call__ ( self , z ) special \u00b6 Computes the distribution of interest from an initial point. Parameters: Name Type Description Default z Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]] Input point from which the distribution is derived. required Returns: Type Description List[Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]]] List of points which are all assigned equal probability mass in the distribution of interest, i.e., the distribution of interest is a discrete, uniform distribution over the list of returned points. Each point in the list shares the same type and shape as z . Source code in trulens/nn/distributions.py @abstractmethod def __call__ ( self , z : ArrayLike ) -> List [ ArrayLike ]: \"\"\" Computes the distribution of interest from an initial point. Parameters: z: Input point from which the distribution is derived. Returns: List of points which are all assigned equal probability mass in the distribution of interest, i.e., the distribution of interest is a discrete, uniform distribution over the list of returned points. Each point in the list shares the same type and shape as `z`. \"\"\" raise NotImplementedError __init__ ( self , cut = None ) special \u00b6 \"Initialize DoI Parameters: Name Type Description Default cut Cut The Cut in which the DoI will be applied. If None , the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. None Source code in trulens/nn/distributions.py def __init__ ( self , cut : Cut = None ): \"\"\"\"Initialize DoI Parameters: cut (Cut, optional): The Cut in which the DoI will be applied. If `None`, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. \"\"\" self . _cut = cut cut ( self ) \u00b6 Returns: Type Description Cut The Cut in which the DoI will be applied. If None , the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. Source code in trulens/nn/distributions.py def cut ( self ) -> Cut : \"\"\" Returns: The Cut in which the DoI will be applied. If `None`, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. \"\"\" return self . _cut get_activation_multiplier ( self , activation ) \u00b6 Returns a term to multiply the gradient by to convert from \" influence space \" to \" attribution space \". Conceptually, \"influence space\" corresponds to the potential effect of a slight increase in each feature, while \"attribution space\" corresponds to an approximation of the net marginal contribution to the quantity of interest of each feature. Parameters: Name Type Description Default activation Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]] The activation of the layer the DoI is applied to. required Returns: Type Description Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]] An array with the same shape as activation that will be multiplied by the gradient to obtain the attribution. The default implementation of this method simply returns activation . Source code in trulens/nn/distributions.py def get_activation_multiplier ( self , activation : ArrayLike ) -> ArrayLike : \"\"\" Returns a term to multiply the gradient by to convert from \"*influence space*\" to \"*attribution space*\". Conceptually, \"influence space\" corresponds to the potential effect of a slight increase in each feature, while \"attribution space\" corresponds to an approximation of the net marginal contribution to the quantity of interest of each feature. Parameters: activation: The activation of the layer the DoI is applied to. Returns: An array with the same shape as ``activation`` that will be multiplied by the gradient to obtain the attribution. The default implementation of this method simply returns ``activation``. \"\"\" return activation DoiCutSupportError \u00b6 Exception raised if the distribution of interest is called on a cut whose output is not supported by the distribution of interest. GaussianDoi \u00b6 Distribution representing a Gaussian ball around the point. Used by Smooth Gradients. __init__ ( self , var , resolution , cut = None ) special \u00b6 Parameters: Name Type Description Default var float The variance of the Gaussian noise to be added around the point. required resolution int Number of samples returned by each call to this DoI. required cut Cut The Cut in which the DoI will be applied. If None , the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. None Source code in trulens/nn/distributions.py def __init__ ( self , var : float , resolution : int , cut : Cut = None ): \"\"\" Parameters: var: The variance of the Gaussian noise to be added around the point. resolution: Number of samples returned by each call to this DoI. cut (Cut, optional): The Cut in which the DoI will be applied. If `None`, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. \"\"\" super ( GaussianDoi , self ) . __init__ ( cut ) self . _var = var self . _resolution = resolution LinearDoi \u00b6 Distribution representing the linear interpolation between a baseline and the given point. Used by Integrated Gradients. __init__ ( self , baseline = None , resolution = 10 , cut = None ) special \u00b6 The DoI for point, z , will be a uniform distribution over the points on the line segment connecting z to baseline , approximated by a sample of resolution points equally spaced along this segment. Parameters: Name Type Description Default baseline Optional[Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]]] The baseline to interpolate from. Must be same shape as the space the distribution acts over, i.e., the shape of the points, z , eventually passed to __call__ . If cut is None , this must be the same shape as the input, otherwise this must be the same shape as the latent space defined by the cut. If None is given, baseline will be the zero vector in the appropriate shape. None resolution int Number of points returned by each call to this DoI. A higher resolution is more computationally expensive, but gives a better approximation of the DoI this object mathematically represents. 10 cut Cut The Cut in which the DoI will be applied. If None , the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. None Source code in trulens/nn/distributions.py def __init__ ( self , baseline : Optional [ ArrayLike ] = None , resolution : int = 10 , cut : Cut = None ): \"\"\" The DoI for point, `z`, will be a uniform distribution over the points on the line segment connecting `z` to `baseline`, approximated by a sample of `resolution` points equally spaced along this segment. Parameters: baseline: The baseline to interpolate from. Must be same shape as the space the distribution acts over, i.e., the shape of the points, `z`, eventually passed to `__call__`. If `cut` is `None`, this must be the same shape as the input, otherwise this must be the same shape as the latent space defined by the cut. If `None` is given, `baseline` will be the zero vector in the appropriate shape. resolution: Number of points returned by each call to this DoI. A higher resolution is more computationally expensive, but gives a better approximation of the DoI this object mathematically represents. cut (Cut, optional): The Cut in which the DoI will be applied. If `None`, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. \"\"\" super ( LinearDoi , self ) . __init__ ( cut ) self . _baseline = baseline self . _resolution = resolution get_activation_multiplier ( self , activation ) \u00b6 Returns a term to multiply the gradient by to convert from \" influence space \" to \" attribution space \". Conceptually, \"influence space\" corresponds to the potential effect of a slight increase in each feature, while \"attribution space\" corresponds to an approximation of the net marginal contribution to the quantity of interest of each feature. Parameters: Name Type Description Default activation Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]] The activation of the layer the DoI is applied to. required Returns: Type Description Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]] The activation adjusted by the baseline passed to the constructor. Source code in trulens/nn/distributions.py def get_activation_multiplier ( self , activation : ArrayLike ) -> ArrayLike : \"\"\" Returns a term to multiply the gradient by to convert from \"*influence space*\" to \"*attribution space*\". Conceptually, \"influence space\" corresponds to the potential effect of a slight increase in each feature, while \"attribution space\" corresponds to an approximation of the net marginal contribution to the quantity of interest of each feature. Parameters: activation: The activation of the layer the DoI is applied to. Returns: The activation adjusted by the baseline passed to the constructor. \"\"\" return ( activation if self . _baseline is None else activation - self . _baseline ) PointDoi \u00b6 Distribution that puts all probability mass on a single point. __init__ ( self , cut = None ) special \u00b6 \"Initialize PointDoI Parameters: Name Type Description Default cut Cut The Cut in which the DoI will be applied. If None , the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. None Source code in trulens/nn/distributions.py def __init__ ( self , cut : Cut = None ): \"\"\"\"Initialize PointDoI Parameters: cut (Cut, optional): The Cut in which the DoI will be applied. If `None`, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. \"\"\" super ( PointDoi , self ) . __init__ ( cut )","title":"Distributions"},{"location":"api/distributions/#distributions-of-interest","text":"","title":"Distributions of Interest"},{"location":"api/distributions/#trulens.nn.distributions","text":"The distribution of interest lets us specify the set of samples over which we want our explanations to be faithful. In some cases, we may want to explain the model\u2019s behavior on a particular record, whereas other times we may be interested in a more general behavior over a distribution of samples.","title":"trulens.nn.distributions"},{"location":"api/distributions/#trulens.nn.distributions.DoI","text":"Interface for distributions of interest. The Distribution of Interest (DoI) specifies the samples over which an attribution method is aggregated.","title":"DoI"},{"location":"api/distributions/#trulens.nn.distributions.DoI.__call__","text":"Computes the distribution of interest from an initial point. Parameters: Name Type Description Default z Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]] Input point from which the distribution is derived. required Returns: Type Description List[Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]]] List of points which are all assigned equal probability mass in the distribution of interest, i.e., the distribution of interest is a discrete, uniform distribution over the list of returned points. Each point in the list shares the same type and shape as z . Source code in trulens/nn/distributions.py @abstractmethod def __call__ ( self , z : ArrayLike ) -> List [ ArrayLike ]: \"\"\" Computes the distribution of interest from an initial point. Parameters: z: Input point from which the distribution is derived. Returns: List of points which are all assigned equal probability mass in the distribution of interest, i.e., the distribution of interest is a discrete, uniform distribution over the list of returned points. Each point in the list shares the same type and shape as `z`. \"\"\" raise NotImplementedError","title":"__call__()"},{"location":"api/distributions/#trulens.nn.distributions.DoI.__init__","text":"\"Initialize DoI Parameters: Name Type Description Default cut Cut The Cut in which the DoI will be applied. If None , the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. None Source code in trulens/nn/distributions.py def __init__ ( self , cut : Cut = None ): \"\"\"\"Initialize DoI Parameters: cut (Cut, optional): The Cut in which the DoI will be applied. If `None`, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. \"\"\" self . _cut = cut","title":"__init__()"},{"location":"api/distributions/#trulens.nn.distributions.DoI.cut","text":"Returns: Type Description Cut The Cut in which the DoI will be applied. If None , the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. Source code in trulens/nn/distributions.py def cut ( self ) -> Cut : \"\"\" Returns: The Cut in which the DoI will be applied. If `None`, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. \"\"\" return self . _cut","title":"cut()"},{"location":"api/distributions/#trulens.nn.distributions.DoI.get_activation_multiplier","text":"Returns a term to multiply the gradient by to convert from \" influence space \" to \" attribution space \". Conceptually, \"influence space\" corresponds to the potential effect of a slight increase in each feature, while \"attribution space\" corresponds to an approximation of the net marginal contribution to the quantity of interest of each feature. Parameters: Name Type Description Default activation Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]] The activation of the layer the DoI is applied to. required Returns: Type Description Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]] An array with the same shape as activation that will be multiplied by the gradient to obtain the attribution. The default implementation of this method simply returns activation . Source code in trulens/nn/distributions.py def get_activation_multiplier ( self , activation : ArrayLike ) -> ArrayLike : \"\"\" Returns a term to multiply the gradient by to convert from \"*influence space*\" to \"*attribution space*\". Conceptually, \"influence space\" corresponds to the potential effect of a slight increase in each feature, while \"attribution space\" corresponds to an approximation of the net marginal contribution to the quantity of interest of each feature. Parameters: activation: The activation of the layer the DoI is applied to. Returns: An array with the same shape as ``activation`` that will be multiplied by the gradient to obtain the attribution. The default implementation of this method simply returns ``activation``. \"\"\" return activation","title":"get_activation_multiplier()"},{"location":"api/distributions/#trulens.nn.distributions.DoiCutSupportError","text":"Exception raised if the distribution of interest is called on a cut whose output is not supported by the distribution of interest.","title":"DoiCutSupportError"},{"location":"api/distributions/#trulens.nn.distributions.GaussianDoi","text":"Distribution representing a Gaussian ball around the point. Used by Smooth Gradients.","title":"GaussianDoi"},{"location":"api/distributions/#trulens.nn.distributions.GaussianDoi.__init__","text":"Parameters: Name Type Description Default var float The variance of the Gaussian noise to be added around the point. required resolution int Number of samples returned by each call to this DoI. required cut Cut The Cut in which the DoI will be applied. If None , the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. None Source code in trulens/nn/distributions.py def __init__ ( self , var : float , resolution : int , cut : Cut = None ): \"\"\" Parameters: var: The variance of the Gaussian noise to be added around the point. resolution: Number of samples returned by each call to this DoI. cut (Cut, optional): The Cut in which the DoI will be applied. If `None`, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. \"\"\" super ( GaussianDoi , self ) . __init__ ( cut ) self . _var = var self . _resolution = resolution","title":"__init__()"},{"location":"api/distributions/#trulens.nn.distributions.LinearDoi","text":"Distribution representing the linear interpolation between a baseline and the given point. Used by Integrated Gradients.","title":"LinearDoi"},{"location":"api/distributions/#trulens.nn.distributions.LinearDoi.__init__","text":"The DoI for point, z , will be a uniform distribution over the points on the line segment connecting z to baseline , approximated by a sample of resolution points equally spaced along this segment. Parameters: Name Type Description Default baseline Optional[Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]]] The baseline to interpolate from. Must be same shape as the space the distribution acts over, i.e., the shape of the points, z , eventually passed to __call__ . If cut is None , this must be the same shape as the input, otherwise this must be the same shape as the latent space defined by the cut. If None is given, baseline will be the zero vector in the appropriate shape. None resolution int Number of points returned by each call to this DoI. A higher resolution is more computationally expensive, but gives a better approximation of the DoI this object mathematically represents. 10 cut Cut The Cut in which the DoI will be applied. If None , the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. None Source code in trulens/nn/distributions.py def __init__ ( self , baseline : Optional [ ArrayLike ] = None , resolution : int = 10 , cut : Cut = None ): \"\"\" The DoI for point, `z`, will be a uniform distribution over the points on the line segment connecting `z` to `baseline`, approximated by a sample of `resolution` points equally spaced along this segment. Parameters: baseline: The baseline to interpolate from. Must be same shape as the space the distribution acts over, i.e., the shape of the points, `z`, eventually passed to `__call__`. If `cut` is `None`, this must be the same shape as the input, otherwise this must be the same shape as the latent space defined by the cut. If `None` is given, `baseline` will be the zero vector in the appropriate shape. resolution: Number of points returned by each call to this DoI. A higher resolution is more computationally expensive, but gives a better approximation of the DoI this object mathematically represents. cut (Cut, optional): The Cut in which the DoI will be applied. If `None`, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. \"\"\" super ( LinearDoi , self ) . __init__ ( cut ) self . _baseline = baseline self . _resolution = resolution","title":"__init__()"},{"location":"api/distributions/#trulens.nn.distributions.LinearDoi.get_activation_multiplier","text":"Returns a term to multiply the gradient by to convert from \" influence space \" to \" attribution space \". Conceptually, \"influence space\" corresponds to the potential effect of a slight increase in each feature, while \"attribution space\" corresponds to an approximation of the net marginal contribution to the quantity of interest of each feature. Parameters: Name Type Description Default activation Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]] The activation of the layer the DoI is applied to. required Returns: Type Description Union[numpy.ndarray, Any, List[Union[numpy.ndarray, Any]]] The activation adjusted by the baseline passed to the constructor. Source code in trulens/nn/distributions.py def get_activation_multiplier ( self , activation : ArrayLike ) -> ArrayLike : \"\"\" Returns a term to multiply the gradient by to convert from \"*influence space*\" to \"*attribution space*\". Conceptually, \"influence space\" corresponds to the potential effect of a slight increase in each feature, while \"attribution space\" corresponds to an approximation of the net marginal contribution to the quantity of interest of each feature. Parameters: activation: The activation of the layer the DoI is applied to. Returns: The activation adjusted by the baseline passed to the constructor. \"\"\" return ( activation if self . _baseline is None else activation - self . _baseline )","title":"get_activation_multiplier()"},{"location":"api/distributions/#trulens.nn.distributions.PointDoi","text":"Distribution that puts all probability mass on a single point.","title":"PointDoi"},{"location":"api/distributions/#trulens.nn.distributions.PointDoi.__init__","text":"\"Initialize PointDoI Parameters: Name Type Description Default cut Cut The Cut in which the DoI will be applied. If None , the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. None Source code in trulens/nn/distributions.py def __init__ ( self , cut : Cut = None ): \"\"\"\"Initialize PointDoI Parameters: cut (Cut, optional): The Cut in which the DoI will be applied. If `None`, the DoI will be applied to the input. otherwise, the distribution should be applied to the latent space defined by the cut. \"\"\" super ( PointDoi , self ) . __init__ ( cut )","title":"__init__()"},{"location":"api/model_wrappers/","text":"Model Wrappers \u00b6 \u00b6 The TruLens library is designed to support models implemented via a variety of different popular python neural network frameworks: Keras (with TensorFlow or Theano backend), TensorFlow, and Pytorch. Models developed with different frameworks implement things (e.g., gradient computations) a number of different ways. We define framework specific ModelWrapper instances to create a unified model API, providing the same functionality to models that are implemented in disparate frameworks. In order to compute attributions for a model, we provide a trulens.nn.models.get_model_wrapper function that will return an appropriate ModelWrapper instance. Some parameters are exclusively utilized for specific frameworks and are outlined in the parameter descriptions. get_model_wrapper ( model , logit_layer = None , replace_softmax = False , softmax_layer =- 1 , custom_objects = None , input_shape = None , input_dtype = None , device = None , input_tensors = None , output_tensors = None , internal_tensor_dict = None , default_feed_dict = None , session = None , backend = None ) \u00b6 Returns a ModelWrapper implementation that exposes the components needed for computing attributions. Parameters: Name Type Description Default model The model to wrap. If using the TensorFlow 1 backend, this is expected to be a graph object. required logit_layer Supported for Keras and Pytorch models. Specifies the name or index of the layer that produces the logit predictions. None replace_softmax Supported for Keras models only. If true, the activation function in the softmax layer (specified by softmax_layer ) will be changed to a 'linear' activation. False softmax_layer Supported for Keras models only. Specifies the layer that performs the softmax. This layer should have an activation attribute. Only used when replace_softmax is true. -1 custom_objects Optional, for use with Keras models only. A dictionary of custom objects used by the Keras model. None input_shape Required for use with Pytorch models only. Tuple specifying the input shape (excluding the batch dimension) expected by the model. None input_dtype torch.dtype Optional, for use with Pytorch models only. , The dtype of the input. None device Optional, for use with Pytorch models only. A string specifying the device to run the model on. None input_tensors Required for use with TensorFlow 1 graph models only. A list of tensors representing the input to the model graph. None output_tensors Required for use with TensorFlow 1 graph models only. A list of tensors representing the output to the model graph. None internal_tensor_dict Optional, for use with TensorFlow 1 graph models only. A dictionary mapping user-selected layer names to the internal tensors in the model graph that the user would like to expose. This is provided to give more human-readable names to the layers if desired. Internal tensors can also be accessed via the name given to them by tensorflow. None default_feed_dict Optional, for use with TensorFlow 1 graph models only. A dictionary of default values to give to tensors in the model graph. None session Optional, for use with TensorFlow 1 graph models only. A tf.Session object to run the model graph in. If None , a new temporary session will be generated every time the model is run. None backend Optional, for forcing a specific backend. String values recognized are pytorch, tensorflow, keras, or tf.keras. None Source code in trulens/nn/models/__init__.py def get_model_wrapper ( model , logit_layer = None , replace_softmax = False , softmax_layer =- 1 , custom_objects = None , input_shape = None , input_dtype = None , device = None , input_tensors = None , output_tensors = None , internal_tensor_dict = None , default_feed_dict = None , session = None , backend = None ): \"\"\" Returns a ModelWrapper implementation that exposes the components needed for computing attributions. Parameters: model: The model to wrap. If using the TensorFlow 1 backend, this is expected to be a graph object. logit_layer: _Supported for Keras and Pytorch models._ Specifies the name or index of the layer that produces the logit predictions. replace_softmax: _Supported for Keras models only._ If true, the activation function in the softmax layer (specified by `softmax_layer`) will be changed to a `'linear'` activation. softmax_layer: _Supported for Keras models only._ Specifies the layer that performs the softmax. This layer should have an `activation` attribute. Only used when `replace_softmax` is true. custom_objects: _Optional, for use with Keras models only._ A dictionary of custom objects used by the Keras model. input_shape: _Required for use with Pytorch models only._ Tuple specifying the input shape (excluding the batch dimension) expected by the model. input_dtype: torch.dtype _Optional, for use with Pytorch models only._, The dtype of the input. device: _Optional, for use with Pytorch models only._ A string specifying the device to run the model on. input_tensors: _Required for use with TensorFlow 1 graph models only._ A list of tensors representing the input to the model graph. output_tensors: _Required for use with TensorFlow 1 graph models only._ A list of tensors representing the output to the model graph. internal_tensor_dict: _Optional, for use with TensorFlow 1 graph models only._ A dictionary mapping user-selected layer names to the internal tensors in the model graph that the user would like to expose. This is provided to give more human-readable names to the layers if desired. Internal tensors can also be accessed via the name given to them by tensorflow. default_feed_dict: _Optional, for use with TensorFlow 1 graph models only._ A dictionary of default values to give to tensors in the model graph. session: _Optional, for use with TensorFlow 1 graph models only._ A `tf.Session` object to run the model graph in. If `None`, a new temporary session will be generated every time the model is run. backend: _Optional, for forcing a specific backend._ String values recognized are pytorch, tensorflow, keras, or tf.keras. \"\"\" # get existing backend B = get_backend ( suppress_warnings = True ) if backend is None : backend = discern_backend ( model ) tru_logger . info ( \"Detected {} backend for {} .\" . format ( backend . name . lower (), type ( model ))) else : backend = Backend . from_name ( backend ) if B is None or ( backend is not Backend . UNKNOWN and B . backend != backend ): tru_logger . info ( \"Changing backend from {} to {} .\" . format ( None if B is None else B . backend , backend )) os . environ [ 'TRULENS_BACKEND' ] = backend . name . lower () B = get_backend () else : tru_logger . info ( \"Using backend {} .\" . format ( B . backend )) tru_logger . info ( \"If this seems incorrect, you can force the correct backend by passing the `backend` parameter directly into your get_model_wrapper call.\" ) if B . backend . is_keras_derivative (): from trulens.nn.models.keras import KerasModelWrapper return KerasModelWrapper ( model , logit_layer = logit_layer , replace_softmax = replace_softmax , softmax_layer = softmax_layer , custom_objects = custom_objects ) elif B . backend == Backend . PYTORCH : from trulens.nn.models.pytorch import PytorchModelWrapper if input_shape is None : tru_logger . error ( 'pytorch model must pass parameter: input_shape' ) return PytorchModelWrapper ( model , input_shape , input_dtype = input_dtype , logit_layer = logit_layer , device = device ) elif B . backend == Backend . TENSORFLOW : import tensorflow as tf if tf . __version__ . startswith ( '2' ): from trulens.nn.models.tensorflow_v2 import Tensorflow2ModelWrapper return Tensorflow2ModelWrapper ( model , logit_layer = logit_layer , replace_softmax = replace_softmax , softmax_layer = softmax_layer , custom_objects = custom_objects ) else : from trulens.nn.models.tensorflow_v1 import TensorflowModelWrapper if input_tensors is None : tru_logger . error ( 'tensorflow1 model must pass parameter: input_tensors' ) if output_tensors is None : tru_logger . error ( 'tensorflow1 model must pass parameter: output_tensors' ) return TensorflowModelWrapper ( model , input_tensors , output_tensors , internal_tensor_dict = internal_tensor_dict , session = session )","title":"Models"},{"location":"api/model_wrappers/#model-wrappers","text":"","title":"Model Wrappers"},{"location":"api/model_wrappers/#trulens.nn.models.__init__","text":"The TruLens library is designed to support models implemented via a variety of different popular python neural network frameworks: Keras (with TensorFlow or Theano backend), TensorFlow, and Pytorch. Models developed with different frameworks implement things (e.g., gradient computations) a number of different ways. We define framework specific ModelWrapper instances to create a unified model API, providing the same functionality to models that are implemented in disparate frameworks. In order to compute attributions for a model, we provide a trulens.nn.models.get_model_wrapper function that will return an appropriate ModelWrapper instance. Some parameters are exclusively utilized for specific frameworks and are outlined in the parameter descriptions.","title":"trulens.nn.models.__init__"},{"location":"api/model_wrappers/#trulens.nn.models.__init__.get_model_wrapper","text":"Returns a ModelWrapper implementation that exposes the components needed for computing attributions. Parameters: Name Type Description Default model The model to wrap. If using the TensorFlow 1 backend, this is expected to be a graph object. required logit_layer Supported for Keras and Pytorch models. Specifies the name or index of the layer that produces the logit predictions. None replace_softmax Supported for Keras models only. If true, the activation function in the softmax layer (specified by softmax_layer ) will be changed to a 'linear' activation. False softmax_layer Supported for Keras models only. Specifies the layer that performs the softmax. This layer should have an activation attribute. Only used when replace_softmax is true. -1 custom_objects Optional, for use with Keras models only. A dictionary of custom objects used by the Keras model. None input_shape Required for use with Pytorch models only. Tuple specifying the input shape (excluding the batch dimension) expected by the model. None input_dtype torch.dtype Optional, for use with Pytorch models only. , The dtype of the input. None device Optional, for use with Pytorch models only. A string specifying the device to run the model on. None input_tensors Required for use with TensorFlow 1 graph models only. A list of tensors representing the input to the model graph. None output_tensors Required for use with TensorFlow 1 graph models only. A list of tensors representing the output to the model graph. None internal_tensor_dict Optional, for use with TensorFlow 1 graph models only. A dictionary mapping user-selected layer names to the internal tensors in the model graph that the user would like to expose. This is provided to give more human-readable names to the layers if desired. Internal tensors can also be accessed via the name given to them by tensorflow. None default_feed_dict Optional, for use with TensorFlow 1 graph models only. A dictionary of default values to give to tensors in the model graph. None session Optional, for use with TensorFlow 1 graph models only. A tf.Session object to run the model graph in. If None , a new temporary session will be generated every time the model is run. None backend Optional, for forcing a specific backend. String values recognized are pytorch, tensorflow, keras, or tf.keras. None Source code in trulens/nn/models/__init__.py def get_model_wrapper ( model , logit_layer = None , replace_softmax = False , softmax_layer =- 1 , custom_objects = None , input_shape = None , input_dtype = None , device = None , input_tensors = None , output_tensors = None , internal_tensor_dict = None , default_feed_dict = None , session = None , backend = None ): \"\"\" Returns a ModelWrapper implementation that exposes the components needed for computing attributions. Parameters: model: The model to wrap. If using the TensorFlow 1 backend, this is expected to be a graph object. logit_layer: _Supported for Keras and Pytorch models._ Specifies the name or index of the layer that produces the logit predictions. replace_softmax: _Supported for Keras models only._ If true, the activation function in the softmax layer (specified by `softmax_layer`) will be changed to a `'linear'` activation. softmax_layer: _Supported for Keras models only._ Specifies the layer that performs the softmax. This layer should have an `activation` attribute. Only used when `replace_softmax` is true. custom_objects: _Optional, for use with Keras models only._ A dictionary of custom objects used by the Keras model. input_shape: _Required for use with Pytorch models only._ Tuple specifying the input shape (excluding the batch dimension) expected by the model. input_dtype: torch.dtype _Optional, for use with Pytorch models only._, The dtype of the input. device: _Optional, for use with Pytorch models only._ A string specifying the device to run the model on. input_tensors: _Required for use with TensorFlow 1 graph models only._ A list of tensors representing the input to the model graph. output_tensors: _Required for use with TensorFlow 1 graph models only._ A list of tensors representing the output to the model graph. internal_tensor_dict: _Optional, for use with TensorFlow 1 graph models only._ A dictionary mapping user-selected layer names to the internal tensors in the model graph that the user would like to expose. This is provided to give more human-readable names to the layers if desired. Internal tensors can also be accessed via the name given to them by tensorflow. default_feed_dict: _Optional, for use with TensorFlow 1 graph models only._ A dictionary of default values to give to tensors in the model graph. session: _Optional, for use with TensorFlow 1 graph models only._ A `tf.Session` object to run the model graph in. If `None`, a new temporary session will be generated every time the model is run. backend: _Optional, for forcing a specific backend._ String values recognized are pytorch, tensorflow, keras, or tf.keras. \"\"\" # get existing backend B = get_backend ( suppress_warnings = True ) if backend is None : backend = discern_backend ( model ) tru_logger . info ( \"Detected {} backend for {} .\" . format ( backend . name . lower (), type ( model ))) else : backend = Backend . from_name ( backend ) if B is None or ( backend is not Backend . UNKNOWN and B . backend != backend ): tru_logger . info ( \"Changing backend from {} to {} .\" . format ( None if B is None else B . backend , backend )) os . environ [ 'TRULENS_BACKEND' ] = backend . name . lower () B = get_backend () else : tru_logger . info ( \"Using backend {} .\" . format ( B . backend )) tru_logger . info ( \"If this seems incorrect, you can force the correct backend by passing the `backend` parameter directly into your get_model_wrapper call.\" ) if B . backend . is_keras_derivative (): from trulens.nn.models.keras import KerasModelWrapper return KerasModelWrapper ( model , logit_layer = logit_layer , replace_softmax = replace_softmax , softmax_layer = softmax_layer , custom_objects = custom_objects ) elif B . backend == Backend . PYTORCH : from trulens.nn.models.pytorch import PytorchModelWrapper if input_shape is None : tru_logger . error ( 'pytorch model must pass parameter: input_shape' ) return PytorchModelWrapper ( model , input_shape , input_dtype = input_dtype , logit_layer = logit_layer , device = device ) elif B . backend == Backend . TENSORFLOW : import tensorflow as tf if tf . __version__ . startswith ( '2' ): from trulens.nn.models.tensorflow_v2 import Tensorflow2ModelWrapper return Tensorflow2ModelWrapper ( model , logit_layer = logit_layer , replace_softmax = replace_softmax , softmax_layer = softmax_layer , custom_objects = custom_objects ) else : from trulens.nn.models.tensorflow_v1 import TensorflowModelWrapper if input_tensors is None : tru_logger . error ( 'tensorflow1 model must pass parameter: input_tensors' ) if output_tensors is None : tru_logger . error ( 'tensorflow1 model must pass parameter: output_tensors' ) return TensorflowModelWrapper ( model , input_tensors , output_tensors , internal_tensor_dict = internal_tensor_dict , session = session )","title":"get_model_wrapper()"},{"location":"api/quantities/","text":"Quantities of Interest \u00b6 \u00b6 A Quantity of Interest (QoI) is a function of the output that determines the network output behavior that the attributions describe. The quantity of interest lets us specify what we want to explain. Often, this is the output of the network corresponding to a particular class, addressing, e.g., \"Why did the model classify a given image as a car?\" However, we could also consider various combinations of outputs, allowing us to ask more specific questions, such as, \"Why did the model classify a given image as a sedan and not a convertible ?\" The former may highlight general \u201ccar features,\u201d such as tires, while the latter (called a comparative explanation) might focus on the roof of the car, a \u201ccar feature\u201d not shared by convertibles. ClassQoI \u00b6 Quantity of interest for attributing output towards a specified class. __init__ ( self , cl ) special \u00b6 Parameters: Name Type Description Default cl int The index of the class the QoI is for. required Source code in trulens/nn/quantities.py def __init__ ( self , cl : int ): \"\"\" Parameters: cl: The index of the class the QoI is for. \"\"\" self . cl = cl ClassSeqQoI \u00b6 Quantity of interest for attributing output towards a sequence of classes for each input. __init__ ( self , seq_labels ) special \u00b6 Parameters: Name Type Description Default seq_labels List[int] A sequence of classes corresponding to each input. required Source code in trulens/nn/quantities.py def __init__ ( self , seq_labels : List [ int ]): \"\"\" Parameters: seq_labels: A sequence of classes corresponding to each input. \"\"\" self . seq_labels = seq_labels ComparativeQoI \u00b6 Quantity of interest for attributing network output towards a given class, relative to another. __init__ ( self , cl1 , cl2 ) special \u00b6 Parameters: Name Type Description Default cl1 int The index of the class the QoI is for. required cl2 int The index of the class to compare against. required Source code in trulens/nn/quantities.py def __init__ ( self , cl1 : int , cl2 : int ): \"\"\" Parameters: cl1: The index of the class the QoI is for. cl2: The index of the class to compare against. \"\"\" self . cl1 = cl1 self . cl2 = cl2 InternalChannelQoI \u00b6 Quantity of interest for attributing output towards the output of an internal convolutional layer channel, aggregating using a specified operation. Also works for non-convolutional dense layers, where the given neuron's activation is returned. __init__ ( self , channel , channel_axis = None , agg_fn = None ) special \u00b6 Parameters: Name Type Description Default channel Union[int, List[int]] Channel to return. If a list is provided, then the quantity sums over each of the channels in the list. required channel_axis Optional[int] Channel dimension index, if relevant, e.g., for 2D convolutional layers. If channel_axis is None , then the channel axis of the relevant backend will be used. This argument is not used when the channels are scalars, e.g., for dense layers. None agg_fn Optional[Callable] Function with which to aggregate the remaining dimensions (except the batch dimension) in order to get a single scalar value for each channel. If agg_fn is None then a sum over each neuron in the channel will be taken. This argument is not used when the channels are scalars, e.g., for dense layers. None Source code in trulens/nn/quantities.py def __init__ ( self , channel : Union [ int , List [ int ]], channel_axis : Optional [ int ] = None , agg_fn : Optional [ Callable ] = None ): \"\"\" Parameters: channel: Channel to return. If a list is provided, then the quantity sums over each of the channels in the list. channel_axis: Channel dimension index, if relevant, e.g., for 2D convolutional layers. If `channel_axis` is `None`, then the channel axis of the relevant backend will be used. This argument is not used when the channels are scalars, e.g., for dense layers. agg_fn: Function with which to aggregate the remaining dimensions (except the batch dimension) in order to get a single scalar value for each channel. If `agg_fn` is `None` then a sum over each neuron in the channel will be taken. This argument is not used when the channels are scalars, e.g., for dense layers. \"\"\" if channel_axis is None : channel_axis = get_backend () . channel_axis if agg_fn is None : agg_fn = InternalChannelQoI . _batch_sum self . _channel_ax = channel_axis self . _agg_fn = agg_fn self . _channels = channel if isinstance ( channel , list ) else [ channel ] LambdaQoI \u00b6 Generic quantity of interest allowing the user to specify a function of the model's output as the QoI. __init__ ( self , function ) special \u00b6 Parameters: Name Type Description Default function Callable A callable that takes a single argument representing the model's tensor output and returns a differentiable batched scalar tensor representing the QoI. required Source code in trulens/nn/quantities.py def __init__ ( self , function : Callable ): \"\"\" Parameters: function: A callable that takes a single argument representing the model's tensor output and returns a differentiable batched scalar tensor representing the QoI. \"\"\" if len ( signature ( function ) . parameters ) != 1 : raise ValueError ( 'QoI function must take exactly 1 argument, but provided ' 'function takes {} arguments' . format ( len ( signature ( function ) . parameters ))) self . function = function MaxClassQoI \u00b6 Quantity of interest for attributing output towards the maximum-predicted class. __init__ ( self , axis = 1 , activation = None ) special \u00b6 Parameters: Name Type Description Default axis int Output dimension over which max operation is taken. 1 activation Optional[Union[Callable, str]] Activation function to be applied to the output before taking the max. If activation is a string, use the corresponding named activation function implemented by the backend. The following strings are currently supported as shorthands for the respective standard activation functions: 'sigmoid' 'softmax' If activation is None , no activation function is applied to the input. None Source code in trulens/nn/quantities.py def __init__ ( self , axis : int = 1 , activation : Union [ Callable , str , None ] = None ): \"\"\" Parameters: axis: Output dimension over which max operation is taken. activation: Activation function to be applied to the output before taking the max. If `activation` is a string, use the corresponding named activation function implemented by the backend. The following strings are currently supported as shorthands for the respective standard activation functions: - `'sigmoid'` - `'softmax'` If `activation` is `None`, no activation function is applied to the input. \"\"\" self . _axis = axis self . activation = activation QoI \u00b6 Interface for quantities of interest. The Quantity of Interest (QoI) is a function of the output specified by the slice that determines the network output behavior that the attributions describe. __call__ ( self , y ) special \u00b6 Computes the distribution of interest from an initial point. Parameters: Name Type Description Default y Union[Any, List[Any]] Output point from which the quantity is derived. Must be a differentiable tensor. required Returns: Type Description Union[Any, List[Any]] A differentiable batched scalar tensor representing the QoI. Source code in trulens/nn/quantities.py @abstractmethod def __call__ ( self , y : TensorLike ) -> TensorLike : \"\"\" Computes the distribution of interest from an initial point. Parameters: y: Output point from which the quantity is derived. Must be a differentiable tensor. Returns: A differentiable batched scalar tensor representing the QoI. \"\"\" raise NotImplementedError QoiCutSupportError \u00b6 Exception raised if the quantity of interest is called on a cut whose output is not supported by the quantity of interest. ThresholdQoI \u00b6 Quantity of interest for attributing network output toward the difference between two regions seperated by a given threshold. I.e., the quantity of interest is the \"high\" elements minus the \"low\" elements, where the high elements have activations above the threshold and the low elements have activations below the threshold. Use case: bianry segmentation. __init__ ( self , threshold , low_minus_high = False , activation = None ) special \u00b6 Parameters: Name Type Description Default threshold float A threshold to determine the element-wise sign of the input tensor. The elements with activations higher than the threshold will retain their sign, while the elements with activations lower than the threshold will have their sign flipped (or vice versa if low_minus_high is set to True ). required low_minus_high bool If True , substract the output with activations above the threshold from the output with activations below the threshold. If False , substract the output with activations below the threshold from the output with activations above the threshold. False activation Optional[Union[Callable, str]] str or function, optional Activation function to be applied to the quantity before taking the threshold. If activation is a string, use the corresponding activation function implemented by the backend (currently supported: 'sigmoid' and 'softmax' ). Otherwise, if activation is not None , it will be treated as a callable. If activation is None , do not apply an activation function to the quantity. None Source code in trulens/nn/quantities.py def __init__ ( self , threshold : float , low_minus_high : bool = False , activation : Union [ Callable , str , None ] = None ): \"\"\" Parameters: threshold: A threshold to determine the element-wise sign of the input tensor. The elements with activations higher than the threshold will retain their sign, while the elements with activations lower than the threshold will have their sign flipped (or vice versa if `low_minus_high` is set to `True`). low_minus_high: If `True`, substract the output with activations above the threshold from the output with activations below the threshold. If `False`, substract the output with activations below the threshold from the output with activations above the threshold. activation: str or function, optional Activation function to be applied to the quantity before taking the threshold. If `activation` is a string, use the corresponding activation function implemented by the backend (currently supported: `'sigmoid'` and `'softmax'`). Otherwise, if `activation` is not `None`, it will be treated as a callable. If `activation` is `None`, do not apply an activation function to the quantity. \"\"\" # TODO(klas):should this support an aggregation function? By default # this is a sum, but it could, for example, subtract the greatest # positive element from the least negative element. self . threshold = threshold self . low_minus_high = low_minus_high self . activation = activation","title":"Quantities"},{"location":"api/quantities/#quantities-of-interest","text":"","title":"Quantities of Interest"},{"location":"api/quantities/#trulens.nn.quantities","text":"A Quantity of Interest (QoI) is a function of the output that determines the network output behavior that the attributions describe. The quantity of interest lets us specify what we want to explain. Often, this is the output of the network corresponding to a particular class, addressing, e.g., \"Why did the model classify a given image as a car?\" However, we could also consider various combinations of outputs, allowing us to ask more specific questions, such as, \"Why did the model classify a given image as a sedan and not a convertible ?\" The former may highlight general \u201ccar features,\u201d such as tires, while the latter (called a comparative explanation) might focus on the roof of the car, a \u201ccar feature\u201d not shared by convertibles.","title":"trulens.nn.quantities"},{"location":"api/quantities/#trulens.nn.quantities.ClassQoI","text":"Quantity of interest for attributing output towards a specified class.","title":"ClassQoI"},{"location":"api/quantities/#trulens.nn.quantities.ClassQoI.__init__","text":"Parameters: Name Type Description Default cl int The index of the class the QoI is for. required Source code in trulens/nn/quantities.py def __init__ ( self , cl : int ): \"\"\" Parameters: cl: The index of the class the QoI is for. \"\"\" self . cl = cl","title":"__init__()"},{"location":"api/quantities/#trulens.nn.quantities.ClassSeqQoI","text":"Quantity of interest for attributing output towards a sequence of classes for each input.","title":"ClassSeqQoI"},{"location":"api/quantities/#trulens.nn.quantities.ClassSeqQoI.__init__","text":"Parameters: Name Type Description Default seq_labels List[int] A sequence of classes corresponding to each input. required Source code in trulens/nn/quantities.py def __init__ ( self , seq_labels : List [ int ]): \"\"\" Parameters: seq_labels: A sequence of classes corresponding to each input. \"\"\" self . seq_labels = seq_labels","title":"__init__()"},{"location":"api/quantities/#trulens.nn.quantities.ComparativeQoI","text":"Quantity of interest for attributing network output towards a given class, relative to another.","title":"ComparativeQoI"},{"location":"api/quantities/#trulens.nn.quantities.ComparativeQoI.__init__","text":"Parameters: Name Type Description Default cl1 int The index of the class the QoI is for. required cl2 int The index of the class to compare against. required Source code in trulens/nn/quantities.py def __init__ ( self , cl1 : int , cl2 : int ): \"\"\" Parameters: cl1: The index of the class the QoI is for. cl2: The index of the class to compare against. \"\"\" self . cl1 = cl1 self . cl2 = cl2","title":"__init__()"},{"location":"api/quantities/#trulens.nn.quantities.InternalChannelQoI","text":"Quantity of interest for attributing output towards the output of an internal convolutional layer channel, aggregating using a specified operation. Also works for non-convolutional dense layers, where the given neuron's activation is returned.","title":"InternalChannelQoI"},{"location":"api/quantities/#trulens.nn.quantities.InternalChannelQoI.__init__","text":"Parameters: Name Type Description Default channel Union[int, List[int]] Channel to return. If a list is provided, then the quantity sums over each of the channels in the list. required channel_axis Optional[int] Channel dimension index, if relevant, e.g., for 2D convolutional layers. If channel_axis is None , then the channel axis of the relevant backend will be used. This argument is not used when the channels are scalars, e.g., for dense layers. None agg_fn Optional[Callable] Function with which to aggregate the remaining dimensions (except the batch dimension) in order to get a single scalar value for each channel. If agg_fn is None then a sum over each neuron in the channel will be taken. This argument is not used when the channels are scalars, e.g., for dense layers. None Source code in trulens/nn/quantities.py def __init__ ( self , channel : Union [ int , List [ int ]], channel_axis : Optional [ int ] = None , agg_fn : Optional [ Callable ] = None ): \"\"\" Parameters: channel: Channel to return. If a list is provided, then the quantity sums over each of the channels in the list. channel_axis: Channel dimension index, if relevant, e.g., for 2D convolutional layers. If `channel_axis` is `None`, then the channel axis of the relevant backend will be used. This argument is not used when the channels are scalars, e.g., for dense layers. agg_fn: Function with which to aggregate the remaining dimensions (except the batch dimension) in order to get a single scalar value for each channel. If `agg_fn` is `None` then a sum over each neuron in the channel will be taken. This argument is not used when the channels are scalars, e.g., for dense layers. \"\"\" if channel_axis is None : channel_axis = get_backend () . channel_axis if agg_fn is None : agg_fn = InternalChannelQoI . _batch_sum self . _channel_ax = channel_axis self . _agg_fn = agg_fn self . _channels = channel if isinstance ( channel , list ) else [ channel ]","title":"__init__()"},{"location":"api/quantities/#trulens.nn.quantities.LambdaQoI","text":"Generic quantity of interest allowing the user to specify a function of the model's output as the QoI.","title":"LambdaQoI"},{"location":"api/quantities/#trulens.nn.quantities.LambdaQoI.__init__","text":"Parameters: Name Type Description Default function Callable A callable that takes a single argument representing the model's tensor output and returns a differentiable batched scalar tensor representing the QoI. required Source code in trulens/nn/quantities.py def __init__ ( self , function : Callable ): \"\"\" Parameters: function: A callable that takes a single argument representing the model's tensor output and returns a differentiable batched scalar tensor representing the QoI. \"\"\" if len ( signature ( function ) . parameters ) != 1 : raise ValueError ( 'QoI function must take exactly 1 argument, but provided ' 'function takes {} arguments' . format ( len ( signature ( function ) . parameters ))) self . function = function","title":"__init__()"},{"location":"api/quantities/#trulens.nn.quantities.MaxClassQoI","text":"Quantity of interest for attributing output towards the maximum-predicted class.","title":"MaxClassQoI"},{"location":"api/quantities/#trulens.nn.quantities.MaxClassQoI.__init__","text":"Parameters: Name Type Description Default axis int Output dimension over which max operation is taken. 1 activation Optional[Union[Callable, str]] Activation function to be applied to the output before taking the max. If activation is a string, use the corresponding named activation function implemented by the backend. The following strings are currently supported as shorthands for the respective standard activation functions: 'sigmoid' 'softmax' If activation is None , no activation function is applied to the input. None Source code in trulens/nn/quantities.py def __init__ ( self , axis : int = 1 , activation : Union [ Callable , str , None ] = None ): \"\"\" Parameters: axis: Output dimension over which max operation is taken. activation: Activation function to be applied to the output before taking the max. If `activation` is a string, use the corresponding named activation function implemented by the backend. The following strings are currently supported as shorthands for the respective standard activation functions: - `'sigmoid'` - `'softmax'` If `activation` is `None`, no activation function is applied to the input. \"\"\" self . _axis = axis self . activation = activation","title":"__init__()"},{"location":"api/quantities/#trulens.nn.quantities.QoI","text":"Interface for quantities of interest. The Quantity of Interest (QoI) is a function of the output specified by the slice that determines the network output behavior that the attributions describe.","title":"QoI"},{"location":"api/quantities/#trulens.nn.quantities.QoI.__call__","text":"Computes the distribution of interest from an initial point. Parameters: Name Type Description Default y Union[Any, List[Any]] Output point from which the quantity is derived. Must be a differentiable tensor. required Returns: Type Description Union[Any, List[Any]] A differentiable batched scalar tensor representing the QoI. Source code in trulens/nn/quantities.py @abstractmethod def __call__ ( self , y : TensorLike ) -> TensorLike : \"\"\" Computes the distribution of interest from an initial point. Parameters: y: Output point from which the quantity is derived. Must be a differentiable tensor. Returns: A differentiable batched scalar tensor representing the QoI. \"\"\" raise NotImplementedError","title":"__call__()"},{"location":"api/quantities/#trulens.nn.quantities.QoiCutSupportError","text":"Exception raised if the quantity of interest is called on a cut whose output is not supported by the quantity of interest.","title":"QoiCutSupportError"},{"location":"api/quantities/#trulens.nn.quantities.ThresholdQoI","text":"Quantity of interest for attributing network output toward the difference between two regions seperated by a given threshold. I.e., the quantity of interest is the \"high\" elements minus the \"low\" elements, where the high elements have activations above the threshold and the low elements have activations below the threshold. Use case: bianry segmentation.","title":"ThresholdQoI"},{"location":"api/quantities/#trulens.nn.quantities.ThresholdQoI.__init__","text":"Parameters: Name Type Description Default threshold float A threshold to determine the element-wise sign of the input tensor. The elements with activations higher than the threshold will retain their sign, while the elements with activations lower than the threshold will have their sign flipped (or vice versa if low_minus_high is set to True ). required low_minus_high bool If True , substract the output with activations above the threshold from the output with activations below the threshold. If False , substract the output with activations below the threshold from the output with activations above the threshold. False activation Optional[Union[Callable, str]] str or function, optional Activation function to be applied to the quantity before taking the threshold. If activation is a string, use the corresponding activation function implemented by the backend (currently supported: 'sigmoid' and 'softmax' ). Otherwise, if activation is not None , it will be treated as a callable. If activation is None , do not apply an activation function to the quantity. None Source code in trulens/nn/quantities.py def __init__ ( self , threshold : float , low_minus_high : bool = False , activation : Union [ Callable , str , None ] = None ): \"\"\" Parameters: threshold: A threshold to determine the element-wise sign of the input tensor. The elements with activations higher than the threshold will retain their sign, while the elements with activations lower than the threshold will have their sign flipped (or vice versa if `low_minus_high` is set to `True`). low_minus_high: If `True`, substract the output with activations above the threshold from the output with activations below the threshold. If `False`, substract the output with activations below the threshold from the output with activations above the threshold. activation: str or function, optional Activation function to be applied to the quantity before taking the threshold. If `activation` is a string, use the corresponding activation function implemented by the backend (currently supported: `'sigmoid'` and `'softmax'`). Otherwise, if `activation` is not `None`, it will be treated as a callable. If `activation` is `None`, do not apply an activation function to the quantity. \"\"\" # TODO(klas):should this support an aggregation function? By default # this is a sum, but it could, for example, subtract the greatest # positive element from the least negative element. self . threshold = threshold self . low_minus_high = low_minus_high self . activation = activation","title":"__init__()"},{"location":"api/slices/","text":"Slices \u00b6 \u00b6 The slice , or layer, of the network provides flexibility over the level of abstraction for the explanation. In a low layer, an explanation may highlight the edges that were most important in identifying an object like a face, while in a higher layer, the explanation might highlight high-level features such as a nose or mouth. By raising the level of abstraction, explanations that generalize over larger sets of samples are possible. Formally, A network, f f , can be broken into a slice, f = g \\circ h f = g \\circ h , where h h can be thought of as a pre-processor that computes features, and g g can be thought of as a sub-model that uses the features computed by h h . Cut \u00b6 A cut is the primary building block for a slice. It determines an internal component of a network to expose. A slice if formed by two cuts. __init__ ( self , name , anchor = 'out' , accessor = None ) special \u00b6 Parameters: Name Type Description Default name Union[int, str, List[Union[int, str]]] The name or index of a layer in the model, or a list containing the names/indices of mutliple layers. required anchor str Determines whether input ( 'in' ) or the output ( 'out' ) tensor of the spcified layer should be used. 'out' accessor Optional[Callable] An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If accessor is None , the following accessor function will be used: lambda t : t [ - 1 ] if isinstance ( t , list ) else t None Source code in trulens/nn/slices.py def __init__ ( self , name : LayerIdentifier , anchor : str = 'out' , accessor : Optional [ Callable ] = None ): \"\"\" Parameters: name: The name or index of a layer in the model, or a list containing the names/indices of mutliple layers. anchor: Determines whether input (`'in'`) or the output (`'out'`) tensor of the spcified layer should be used. accessor: An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If `accessor` is `None`, the following accessor function will be used: ```python lambda t: t[-1] if isinstance(t, list) else t ``` \"\"\" if get_backend () . backend == 'pytorch' : if ( isinstance ( name , int ) or ( isinstance ( name , list ) and isinstance ( name [ 0 ], int ))): warn ( ' \\n\\n Pytorch does not have native support for indexed ' 'layers. Using layer indices is not recommended. \\n ' ) self . name = name self . accessor = accessor self . anchor = anchor access_layer ( self , layer ) \u00b6 Applies self.accessor to the result of collecting the relevant tensor(s) associated with a layer's output. Parameters: Name Type Description Default layer Union[Any, List[Any]] The tensor output (or input, if so specified by the anchor) of the layer(s) specified by this cut. required Returns: Type Description Union[Any, List[Any]] The result of applying self.accessor to the given layer. Source code in trulens/nn/slices.py def access_layer ( self , layer : TensorLike ) -> TensorLike : \"\"\" Applies `self.accessor` to the result of collecting the relevant tensor(s) associated with a layer's output. Parameters: layer: The tensor output (or input, if so specified by the anchor) of the layer(s) specified by this cut. Returns: The result of applying `self.accessor` to the given layer. \"\"\" if self . accessor is None : return layer [ - 1 ] if isinstance ( layer , list ) else layer else : layer = ( layer [ 0 ] if isinstance ( layer , list ) and len ( layer ) == 1 else layer ) return self . accessor ( layer ) InputCut \u00b6 Special cut that selects the input(s) of a model. __init__ ( self , anchor = 'in' , accessor = None ) special \u00b6 Parameters: Name Type Description Default anchor str Determines whether input ( 'in' ) or the output ( 'out' ) tensor of the spcified layer should be used. 'in' accessor Optional[Callable] An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If accessor is None , the following accessor function will be used: lambda t : t [ - 1 ] if isinstance ( t , list ) else t None Source code in trulens/nn/slices.py def __init__ ( self , anchor : str = 'in' , accessor : Optional [ Callable ] = None ): \"\"\" Parameters: anchor: Determines whether input (`'in'`) or the output (`'out'`) tensor of the spcified layer should be used. accessor: An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If `accessor` is `None`, the following accessor function will be used: ```python lambda t: t[-1] if isinstance(t, list) else t ``` \"\"\" super () . __init__ ( None , anchor , accessor ) LogitCut \u00b6 Special cut that selects the logit layer of a model. The logit layer must be named 'logits' or otherwise specified by the user to the model wrapper. __init__ ( self , anchor = 'out' , accessor = None ) special \u00b6 Parameters: Name Type Description Default anchor str Determines whether input ( 'in' ) or the output ( 'out' ) tensor of the spcified layer should be used. 'out' accessor Optional[Callable] An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If accessor is None , the following accessor function will be used: lambda t : t [ - 1 ] if isinstance ( t , list ) else t None Source code in trulens/nn/slices.py def __init__ ( self , anchor : str = 'out' , accessor : Optional [ Callable ] = None ): \"\"\" Parameters: anchor: Determines whether input (`'in'`) or the output (`'out'`) tensor of the spcified layer should be used. accessor: An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If `accessor` is `None`, the following accessor function will be used: ```python lambda t: t[-1] if isinstance(t, list) else t ``` \"\"\" super ( LogitCut , self ) . __init__ ( None , anchor , accessor ) OutputCut \u00b6 Special cut that selects the output(s) of a model. __init__ ( self , anchor = 'out' , accessor = None ) special \u00b6 Parameters: Name Type Description Default anchor str Determines whether input ( 'in' ) or the output ( 'out' ) tensor of the spcified layer should be used. 'out' accessor Optional[Callable] An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If accessor is None , the following accessor function will be used: lambda t : t [ - 1 ] if isinstance ( t , list ) else t None Source code in trulens/nn/slices.py def __init__ ( self , anchor : str = 'out' , accessor : Optional [ Callable ] = None ): \"\"\" Parameters: anchor: Determines whether input (`'in'`) or the output (`'out'`) tensor of the spcified layer should be used. accessor: An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If `accessor` is `None`, the following accessor function will be used: ```python lambda t: t[-1] if isinstance(t, list) else t ``` \"\"\" super ( OutputCut , self ) . __init__ ( None , anchor , accessor ) Slice \u00b6 Class representing a slice of a network. A network, f f , can be broken into a slice, f = g \\circ h f = g \\circ h , where h h can be thought of as a pre-processor that computes features, and g g can be thought of as a sub-model that uses the features computed by h h . A Slice object represents a slice as two Cut s, from_cut and to_cut , which are the layers corresponding to the output of h h and g g , respectively. from_cut: Cut property readonly \u00b6 Cut representing the output of the preprocessing function, h h , in slice, f = g \\circ h f = g \\circ h . to_cut: Cut property readonly \u00b6 Cut representing the output of the sub-model, g g , in slice, f = g \\circ h f = g \\circ h . __init__ ( self , from_cut , to_cut ) special \u00b6 Parameters: Name Type Description Default from_cut Cut Cut representing the output of the preprocessing function, h h , in slice, f = g \\circ h f = g \\circ h . required to_cut Cut Cut representing the output of the sub-model, g g , in slice, f = g \\circ h f = g \\circ h . required Source code in trulens/nn/slices.py def __init__ ( self , from_cut : Cut , to_cut : Cut ): \"\"\" Parameters: from_cut: Cut representing the output of the preprocessing function, $h$, in slice, $f = g \\\\circ h$. to_cut: Cut representing the output of the sub-model, $g$, in slice, $f = g \\\\circ h$. \"\"\" self . _from_cut = from_cut self . _to_cut = to_cut full_network () staticmethod \u00b6 Returns \u00b6 Slice A slice representing the entire model, i.e., :math: f = g \\circ h , where :math: h is the identity function and :math: g = f . Source code in trulens/nn/slices.py @staticmethod def full_network (): \"\"\" Returns ------- Slice A slice representing the entire model, i.e., :math:`f = g \\\\circ h`, where :math:`h` is the identity function and :math:`g = f`. \"\"\" return Slice ( InputCut (), OutputCut ())","title":"Slices"},{"location":"api/slices/#slices","text":"","title":"Slices"},{"location":"api/slices/#trulens.nn.slices","text":"The slice , or layer, of the network provides flexibility over the level of abstraction for the explanation. In a low layer, an explanation may highlight the edges that were most important in identifying an object like a face, while in a higher layer, the explanation might highlight high-level features such as a nose or mouth. By raising the level of abstraction, explanations that generalize over larger sets of samples are possible. Formally, A network, f f , can be broken into a slice, f = g \\circ h f = g \\circ h , where h h can be thought of as a pre-processor that computes features, and g g can be thought of as a sub-model that uses the features computed by h h .","title":"trulens.nn.slices"},{"location":"api/slices/#trulens.nn.slices.Cut","text":"A cut is the primary building block for a slice. It determines an internal component of a network to expose. A slice if formed by two cuts.","title":"Cut"},{"location":"api/slices/#trulens.nn.slices.Cut.__init__","text":"Parameters: Name Type Description Default name Union[int, str, List[Union[int, str]]] The name or index of a layer in the model, or a list containing the names/indices of mutliple layers. required anchor str Determines whether input ( 'in' ) or the output ( 'out' ) tensor of the spcified layer should be used. 'out' accessor Optional[Callable] An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If accessor is None , the following accessor function will be used: lambda t : t [ - 1 ] if isinstance ( t , list ) else t None Source code in trulens/nn/slices.py def __init__ ( self , name : LayerIdentifier , anchor : str = 'out' , accessor : Optional [ Callable ] = None ): \"\"\" Parameters: name: The name or index of a layer in the model, or a list containing the names/indices of mutliple layers. anchor: Determines whether input (`'in'`) or the output (`'out'`) tensor of the spcified layer should be used. accessor: An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If `accessor` is `None`, the following accessor function will be used: ```python lambda t: t[-1] if isinstance(t, list) else t ``` \"\"\" if get_backend () . backend == 'pytorch' : if ( isinstance ( name , int ) or ( isinstance ( name , list ) and isinstance ( name [ 0 ], int ))): warn ( ' \\n\\n Pytorch does not have native support for indexed ' 'layers. Using layer indices is not recommended. \\n ' ) self . name = name self . accessor = accessor self . anchor = anchor","title":"__init__()"},{"location":"api/slices/#trulens.nn.slices.Cut.access_layer","text":"Applies self.accessor to the result of collecting the relevant tensor(s) associated with a layer's output. Parameters: Name Type Description Default layer Union[Any, List[Any]] The tensor output (or input, if so specified by the anchor) of the layer(s) specified by this cut. required Returns: Type Description Union[Any, List[Any]] The result of applying self.accessor to the given layer. Source code in trulens/nn/slices.py def access_layer ( self , layer : TensorLike ) -> TensorLike : \"\"\" Applies `self.accessor` to the result of collecting the relevant tensor(s) associated with a layer's output. Parameters: layer: The tensor output (or input, if so specified by the anchor) of the layer(s) specified by this cut. Returns: The result of applying `self.accessor` to the given layer. \"\"\" if self . accessor is None : return layer [ - 1 ] if isinstance ( layer , list ) else layer else : layer = ( layer [ 0 ] if isinstance ( layer , list ) and len ( layer ) == 1 else layer ) return self . accessor ( layer )","title":"access_layer()"},{"location":"api/slices/#trulens.nn.slices.InputCut","text":"Special cut that selects the input(s) of a model.","title":"InputCut"},{"location":"api/slices/#trulens.nn.slices.InputCut.__init__","text":"Parameters: Name Type Description Default anchor str Determines whether input ( 'in' ) or the output ( 'out' ) tensor of the spcified layer should be used. 'in' accessor Optional[Callable] An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If accessor is None , the following accessor function will be used: lambda t : t [ - 1 ] if isinstance ( t , list ) else t None Source code in trulens/nn/slices.py def __init__ ( self , anchor : str = 'in' , accessor : Optional [ Callable ] = None ): \"\"\" Parameters: anchor: Determines whether input (`'in'`) or the output (`'out'`) tensor of the spcified layer should be used. accessor: An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If `accessor` is `None`, the following accessor function will be used: ```python lambda t: t[-1] if isinstance(t, list) else t ``` \"\"\" super () . __init__ ( None , anchor , accessor )","title":"__init__()"},{"location":"api/slices/#trulens.nn.slices.LogitCut","text":"Special cut that selects the logit layer of a model. The logit layer must be named 'logits' or otherwise specified by the user to the model wrapper.","title":"LogitCut"},{"location":"api/slices/#trulens.nn.slices.LogitCut.__init__","text":"Parameters: Name Type Description Default anchor str Determines whether input ( 'in' ) or the output ( 'out' ) tensor of the spcified layer should be used. 'out' accessor Optional[Callable] An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If accessor is None , the following accessor function will be used: lambda t : t [ - 1 ] if isinstance ( t , list ) else t None Source code in trulens/nn/slices.py def __init__ ( self , anchor : str = 'out' , accessor : Optional [ Callable ] = None ): \"\"\" Parameters: anchor: Determines whether input (`'in'`) or the output (`'out'`) tensor of the spcified layer should be used. accessor: An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If `accessor` is `None`, the following accessor function will be used: ```python lambda t: t[-1] if isinstance(t, list) else t ``` \"\"\" super ( LogitCut , self ) . __init__ ( None , anchor , accessor )","title":"__init__()"},{"location":"api/slices/#trulens.nn.slices.OutputCut","text":"Special cut that selects the output(s) of a model.","title":"OutputCut"},{"location":"api/slices/#trulens.nn.slices.OutputCut.__init__","text":"Parameters: Name Type Description Default anchor str Determines whether input ( 'in' ) or the output ( 'out' ) tensor of the spcified layer should be used. 'out' accessor Optional[Callable] An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If accessor is None , the following accessor function will be used: lambda t : t [ - 1 ] if isinstance ( t , list ) else t None Source code in trulens/nn/slices.py def __init__ ( self , anchor : str = 'out' , accessor : Optional [ Callable ] = None ): \"\"\" Parameters: anchor: Determines whether input (`'in'`) or the output (`'out'`) tensor of the spcified layer should be used. accessor: An accessor function that operates on the layer, mapping the tensor (or list thereof) corresponding to the layer's input/output to another tensor (or list thereof). This can be used to, e.g., extract a particular output from a layer that produces a sequence of outputs. If `accessor` is `None`, the following accessor function will be used: ```python lambda t: t[-1] if isinstance(t, list) else t ``` \"\"\" super ( OutputCut , self ) . __init__ ( None , anchor , accessor )","title":"__init__()"},{"location":"api/slices/#trulens.nn.slices.Slice","text":"Class representing a slice of a network. A network, f f , can be broken into a slice, f = g \\circ h f = g \\circ h , where h h can be thought of as a pre-processor that computes features, and g g can be thought of as a sub-model that uses the features computed by h h . A Slice object represents a slice as two Cut s, from_cut and to_cut , which are the layers corresponding to the output of h h and g g , respectively.","title":"Slice"},{"location":"api/slices/#trulens.nn.slices.Slice.from_cut","text":"Cut representing the output of the preprocessing function, h h , in slice, f = g \\circ h f = g \\circ h .","title":"from_cut"},{"location":"api/slices/#trulens.nn.slices.Slice.to_cut","text":"Cut representing the output of the sub-model, g g , in slice, f = g \\circ h f = g \\circ h .","title":"to_cut"},{"location":"api/slices/#trulens.nn.slices.Slice.__init__","text":"Parameters: Name Type Description Default from_cut Cut Cut representing the output of the preprocessing function, h h , in slice, f = g \\circ h f = g \\circ h . required to_cut Cut Cut representing the output of the sub-model, g g , in slice, f = g \\circ h f = g \\circ h . required Source code in trulens/nn/slices.py def __init__ ( self , from_cut : Cut , to_cut : Cut ): \"\"\" Parameters: from_cut: Cut representing the output of the preprocessing function, $h$, in slice, $f = g \\\\circ h$. to_cut: Cut representing the output of the sub-model, $g$, in slice, $f = g \\\\circ h$. \"\"\" self . _from_cut = from_cut self . _to_cut = to_cut","title":"__init__()"},{"location":"api/slices/#trulens.nn.slices.Slice.full_network","text":"","title":"full_network()"},{"location":"api/slices/#returns","text":"Slice A slice representing the entire model, i.e., :math: f = g \\circ h , where :math: h is the identity function and :math: g = f . Source code in trulens/nn/slices.py @staticmethod def full_network (): \"\"\" Returns ------- Slice A slice representing the entire model, i.e., :math:`f = g \\\\circ h`, where :math:`h` is the identity function and :math:`g = f`. \"\"\" return Slice ( InputCut (), OutputCut ())","title":"Returns"},{"location":"api/visualizations/","text":"Visualization Methods \u00b6 \u00b6 One clear use case for measuring attributions is for human consumption. In order to be fully leveraged by humans, explanations need to be interpretable \u2014 a large vector of numbers doesn\u2019t in general make us more confident we understand what a network is doing. We therefore view an explanation as comprised of both an attribution measurement and an interpretation of what the attribution values represent. One obvious way to interpret attributions, particularly in the image domain, is via visualization. This module provides several visualization methods for interpreting attributions as images. ChannelMaskVisualizer \u00b6 Uses internal influence to visualize the pixels that are most salient towards a particular internal channel or neuron. __call__ ( self , x , x_preprocessed = None , output_file = None , blur = None , threshold = None , masked_opacity = None , combine_channels = None ) special \u00b6 Visualizes the given attributions by overlaying an attribution heatmap over the given image. Parameters \u00b6 attributions : numpy.ndarray The attributions to visualize. Expected to be in 4-D image format. x : numpy.ndarray The original image(s) over which the attributions are calculated. Must be the same shape as expected by the model used with this visualizer. x_preprocessed : numpy.ndarray, optional If the model requires a preprocessed input (e.g., with the mean subtracted) that is different from how the image should be visualized, x_preprocessed should be specified. In this case x will be used for visualization, and x_preprocessed will be passed to the model when calculating attributions. Must be the same shape as x . output_file : str, optional If specified, the resulting visualization will be saved to a file with the name given by output_file . blur : float, optional If specified, gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If None, defaults to the value supplied to the constructor. Default None. threshold : float Value in the range [0, 1]. Attribution values at or below the percentile given by threshold will be masked. If None, defaults to the value supplied to the constructor. Default None. float Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. Default 0.2. If None, defaults to the value supplied to the constructor. Default None. combine_channels : bool If True, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If None, defaults to the value supplied to the constructor. Default None. Source code in trulens/visualizations.py def __call__ ( self , x , x_preprocessed = None , output_file = None , blur = None , threshold = None , masked_opacity = None , combine_channels = None ): \"\"\" Visualizes the given attributions by overlaying an attribution heatmap over the given image. Parameters ---------- attributions : numpy.ndarray The attributions to visualize. Expected to be in 4-D image format. x : numpy.ndarray The original image(s) over which the attributions are calculated. Must be the same shape as expected by the model used with this visualizer. x_preprocessed : numpy.ndarray, optional If the model requires a preprocessed input (e.g., with the mean subtracted) that is different from how the image should be visualized, ``x_preprocessed`` should be specified. In this case ``x`` will be used for visualization, and ``x_preprocessed`` will be passed to the model when calculating attributions. Must be the same shape as ``x``. output_file : str, optional If specified, the resulting visualization will be saved to a file with the name given by ``output_file``. blur : float, optional If specified, gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If None, defaults to the value supplied to the constructor. Default None. threshold : float Value in the range [0, 1]. Attribution values at or below the percentile given by ``threshold`` will be masked. If None, defaults to the value supplied to the constructor. Default None. masked_opacity: float Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. Default 0.2. If None, defaults to the value supplied to the constructor. Default None. combine_channels : bool If True, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If None, defaults to the value supplied to the constructor. Default None. \"\"\" attrs_input = self . infl_input . attributions ( x if x_preprocessed is None else x_preprocessed ) return self . mask_visualizer ( attrs_input , x , output_file , blur , threshold , masked_opacity , combine_channels ) __init__ ( self , model , layer , channel , channel_axis = None , agg_fn = None , doi = None , blur = None , threshold = 0.5 , masked_opacity = 0.2 , combine_channels = True , use_attr_as_opacity = None , positive_only = None ) special \u00b6 Configures the default parameters for the __call__ method (these can be overridden by passing in values to __call__ ). Parameters: Name Type Description Default model The wrapped model whose channel we're visualizing. required layer The identifier (either index or name) of the layer in which the channel we're visualizing resides. required channel Index of the channel (for convolutional layers) or internal neuron (for fully-connected layers) that we'd like to visualize. required channel_axis If different from the channel axis specified by the backend, the supplied channel_axis will be used if operating on a convolutional layer with 4-D image format. None agg_fn Function with which to aggregate the remaining dimensions (except the batch dimension) in order to get a single scalar value for each channel; If None , a sum over each neuron in the channel will be taken. This argument is not used when the channels are scalars, e.g., for dense layers. None doi The distribution of interest to use when computing the input attributions towards the specified channel. If None , PointDoI will be used. None blur Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. None threshold Value in the range [0, 1]. Attribution values at or below the percentile given by threshold (after normalization, blurring, etc.) will be masked. 0.5 masked_opacity Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. 0.2 combine_channels If True , the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. True use_attr_as_opacity If True , instead of using threshold and masked_opacity , the opacity of each pixel is given by the 0-1-normalized attribution value. None positive_only If True , only pixels with positive attribution will be unmasked (or given nonzero opacity when use_attr_as_opacity is true). None Source code in trulens/visualizations.py def __init__ ( self , model , layer , channel , channel_axis = None , agg_fn = None , doi = None , blur = None , threshold = 0.5 , masked_opacity = 0.2 , combine_channels = True , use_attr_as_opacity = None , positive_only = None ): \"\"\" Configures the default parameters for the `__call__` method (these can be overridden by passing in values to `__call__`). Parameters: model: The wrapped model whose channel we're visualizing. layer: The identifier (either index or name) of the layer in which the channel we're visualizing resides. channel: Index of the channel (for convolutional layers) or internal neuron (for fully-connected layers) that we'd like to visualize. channel_axis: If different from the channel axis specified by the backend, the supplied `channel_axis` will be used if operating on a convolutional layer with 4-D image format. agg_fn: Function with which to aggregate the remaining dimensions (except the batch dimension) in order to get a single scalar value for each channel; If `None`, a sum over each neuron in the channel will be taken. This argument is not used when the channels are scalars, e.g., for dense layers. doi: The distribution of interest to use when computing the input attributions towards the specified channel. If `None`, `PointDoI` will be used. blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. threshold: Value in the range [0, 1]. Attribution values at or below the percentile given by `threshold` (after normalization, blurring, etc.) will be masked. masked_opacity: Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. combine_channels: If `True`, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. use_attr_as_opacity: If `True`, instead of using `threshold` and `masked_opacity`, the opacity of each pixel is given by the 0-1-normalized attribution value. positive_only: If `True`, only pixels with positive attribution will be unmasked (or given nonzero opacity when `use_attr_as_opacity` is true). \"\"\" B = get_backend () if ( B is not None and ( channel_axis is None or channel_axis < 0 )): channel_axis = B . channel_axis elif ( channel_axis is None or channel_axis < 0 ): channel_axis = 1 self . mask_visualizer = MaskVisualizer ( blur , threshold , masked_opacity , combine_channels , use_attr_as_opacity , positive_only ) self . infl_input = InternalInfluence ( model , ( InputCut (), Cut ( layer )), InternalChannelQoI ( channel , channel_axis , agg_fn ), PointDoi () if doi is None else doi ) HeatmapVisualizer \u00b6 Visualizes attributions by overlaying an attribution heatmap over the original image, similar to how GradCAM visualizes attributions. __call__ ( self , attributions , x , output_file = None , imshow = True , fig = None , return_tiled = False , overlay_opacity = None , normalization_type = None , blur = None , cmap = None ) special \u00b6 Visualizes the given attributions by overlaying an attribution heatmap over the given image. Parameters: Name Type Description Default attributions A np.ndarray containing the attributions to be visualized. required x A np.ndarray of items in the same shape as attributions corresponding to the records explained by the given attributions. The visualization will be superimposed onto the corresponding set of records. required output_file File name to save the visualization image to. If None , no image will be saved, but the figure can still be displayed. None imshow If true, a the visualization will be displayed. Otherwise the figure will not be displayed, but the figure can still be saved. True fig The pyplot figure to display the visualization in. If None , a new figure will be created. None return_tiled If true, the returned array will be in the same shape as the visualization, with no batch dimension and the samples in the batch tiled along the width and height dimensions. If false, the returned array will be reshaped to match attributions . False overlay_opacity float Value in the range [0, 1] specifying the opacity for the heatmap overlay. If None , defaults to the value supplied to the constructor. None combine_channels If True , the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If None , defaults to the value supplied to the constructor. required normalization_type Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): 'unsigned_max' : normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. 'unsigned_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'magnitude_max' : takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. 'magnitude_sum' : takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. 'signed_max' : normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. 'signed_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'signed_sum' : scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. '01' : normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. 'unnormalized' : leaves the attributions unaffected. If None , defaults to the value supplied to the constructor. None blur Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If None , defaults to the value supplied to the constructor. None cmap matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If None , defaults to the value supplied to the constructor. None Returns: Type Description A np.ndarray array of the numerical representation of the attributions as modified for the visualization. This includes normalization, blurring, etc. Source code in trulens/visualizations.py def __call__ ( self , attributions , x , output_file = None , imshow = True , fig = None , return_tiled = False , overlay_opacity = None , normalization_type = None , blur = None , cmap = None ): \"\"\" Visualizes the given attributions by overlaying an attribution heatmap over the given image. Parameters: attributions: A `np.ndarray` containing the attributions to be visualized. x: A `np.ndarray` of items in the same shape as `attributions` corresponding to the records explained by the given attributions. The visualization will be superimposed onto the corresponding set of records. output_file: File name to save the visualization image to. If `None`, no image will be saved, but the figure can still be displayed. imshow: If true, a the visualization will be displayed. Otherwise the figure will not be displayed, but the figure can still be saved. fig: The `pyplot` figure to display the visualization in. If `None`, a new figure will be created. return_tiled: If true, the returned array will be in the same shape as the visualization, with no batch dimension and the samples in the batch tiled along the width and height dimensions. If false, the returned array will be reshaped to match `attributions`. overlay_opacity: float Value in the range [0, 1] specifying the opacity for the heatmap overlay. If `None`, defaults to the value supplied to the constructor. combine_channels: If `True`, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If `None`, defaults to the value supplied to the constructor. normalization_type: Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): - `'unsigned_max'`: normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. - `'unsigned_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'magnitude_max'`: takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. - `'magnitude_sum'`: takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. - `'signed_max'`: normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. - `'signed_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'signed_sum'`: scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. - `'01'`: normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. - `'unnormalized'`: leaves the attributions unaffected. If `None`, defaults to the value supplied to the constructor. blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If `None`, defaults to the value supplied to the constructor. cmap: matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If `None`, defaults to the value supplied to the constructor. Returns: A `np.ndarray` array of the numerical representation of the attributions as modified for the visualization. This includes normalization, blurring, etc. \"\"\" _ , normalization_type , blur , cmap = self . _check_args ( attributions , None , normalization_type , blur , cmap ) # Combine the channels. attributions = attributions . mean ( axis = get_backend () . channel_axis , keepdims = True ) # Blur the attributions so the explanation is smoother. if blur : attributions = self . _blur ( attributions , blur ) # Normalize the attributions. attributions = self . _normalize ( attributions , normalization_type ) tiled_attributions = self . tiler . tile ( attributions ) # Normalize the pixels to be in the range [0, 1]. x = self . _normalize ( x , '01' ) tiled_x = self . tiler . tile ( x ) if cmap is None : cmap = self . default_cmap if overlay_opacity is None : overlay_opacity = self . default_overlay_opacity # Display the figure: _fig = plt . figure () if fig is None else fig plt . axis ( 'off' ) plt . imshow ( tiled_x ) plt . imshow ( tiled_attributions , alpha = overlay_opacity , cmap = cmap ) if output_file : plt . savefig ( output_file , bbox_inches = 0 ) if imshow : plt . show () elif fig is None : plt . close ( _fig ) return tiled_attributions if return_tiled else attributions __init__ ( self , overlay_opacity = 0.5 , normalization_type = None , blur = 10.0 , cmap = 'jet' ) special \u00b6 Configures the default parameters for the __call__ method (these can be overridden by passing in values to __call__ ). Parameters: Name Type Description Default overlay_opacity float Value in the range [0, 1] specifying the opacity for the heatmap overlay. 0.5 normalization_type Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): 'unsigned_max' : normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. 'unsigned_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'magnitude_max' : takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. 'magnitude_sum' : takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. 'signed_max' : normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. 'signed_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'signed_sum' : scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. '01' : normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. 'unnormalized' : leaves the attributions unaffected. If None , either 'unsigned_max' (for single-channel data) or 'unsigned_max_positive_centered' (for multi-channel data) is used. None blur Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. 10.0 cmap matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If None , the colormap will be chosen based on the normalization type. This argument is only used for single-channel data (including when combine_channels is True). 'jet' Source code in trulens/visualizations.py def __init__ ( self , overlay_opacity = 0.5 , normalization_type = None , blur = 10. , cmap = 'jet' ): \"\"\" Configures the default parameters for the `__call__` method (these can be overridden by passing in values to `__call__`). Parameters: overlay_opacity: float Value in the range [0, 1] specifying the opacity for the heatmap overlay. normalization_type: Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): - `'unsigned_max'`: normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. - `'unsigned_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'magnitude_max'`: takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. - `'magnitude_sum'`: takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. - `'signed_max'`: normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. - `'signed_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'signed_sum'`: scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. - `'01'`: normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. - `'unnormalized'`: leaves the attributions unaffected. If `None`, either `'unsigned_max'` (for single-channel data) or `'unsigned_max_positive_centered'` (for multi-channel data) is used. blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. cmap: matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If `None`, the colormap will be chosen based on the normalization type. This argument is only used for single-channel data (including when `combine_channels` is True). \"\"\" super () . __init__ ( combine_channels = True , normalization_type = normalization_type , blur = blur , cmap = cmap ) self . default_overlay_opacity = overlay_opacity MaskVisualizer \u00b6 Visualizes attributions by masking the original image to highlight the regions with influence above a given threshold percentile. Intended particularly for use with input-attributions. __init__ ( self , blur = 5.0 , threshold = 0.5 , masked_opacity = 0.2 , combine_channels = True , use_attr_as_opacity = False , positive_only = True ) special \u00b6 Configures the default parameters for the __call__ method (these can be overridden by passing in values to __call__ ). Parameters: Name Type Description Default blur Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. 5.0 threshold Value in the range [0, 1]. Attribution values at or below the percentile given by threshold (after normalization, blurring, etc.) will be masked. 0.5 masked_opacity Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. 0.2 combine_channels If True , the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. True use_attr_as_opacity If True , instead of using threshold and masked_opacity , the opacity of each pixel is given by the 0-1-normalized attribution value. False positive_only If True , only pixels with positive attribution will be unmasked (or given nonzero opacity when use_attr_as_opacity is true). True Source code in trulens/visualizations.py def __init__ ( self , blur = 5. , threshold = 0.5 , masked_opacity = 0.2 , combine_channels = True , use_attr_as_opacity = False , positive_only = True ): \"\"\" Configures the default parameters for the `__call__` method (these can be overridden by passing in values to `__call__`). Parameters: blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. threshold: Value in the range [0, 1]. Attribution values at or below the percentile given by `threshold` (after normalization, blurring, etc.) will be masked. masked_opacity: Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. combine_channels: If `True`, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. use_attr_as_opacity: If `True`, instead of using `threshold` and `masked_opacity`, the opacity of each pixel is given by the 0-1-normalized attribution value. positive_only: If `True`, only pixels with positive attribution will be unmasked (or given nonzero opacity when `use_attr_as_opacity` is true). \"\"\" self . default_blur = blur self . default_thresh = threshold self . default_masked_opacity = masked_opacity self . default_combine_channels = combine_channels # TODO(klas): in the future we can allow configuring of tiling settings # by allowing the user to specify the tiler. self . tiler = Tiler () Tiler \u00b6 Used to tile batched images or attributions. tile ( self , a ) \u00b6 Tiles the given array into a grid that is as square as possible. Parameters: Name Type Description Default a ndarray An array of 4D batched image data. required Returns: Type Description ndarray A tiled array of the images from a . The resulting array has rank 3 for color images, and 2 for grayscale images (the batch dimension is removed, as well as the channel dimension for grayscale images). The resulting array has its color channel dimension ordered last to fit the requirements of the matplotlib library. Source code in trulens/visualizations.py def tile ( self , a : np . ndarray ) -> np . ndarray : \"\"\" Tiles the given array into a grid that is as square as possible. Parameters: a: An array of 4D batched image data. Returns: A tiled array of the images from `a`. The resulting array has rank 3 for color images, and 2 for grayscale images (the batch dimension is removed, as well as the channel dimension for grayscale images). The resulting array has its color channel dimension ordered last to fit the requirements of the `matplotlib` library. \"\"\" # `pyplot` expects the channels to come last. if get_backend () . dim_order == 'channels_first' : a = a . transpose (( 0 , 2 , 3 , 1 )) n , h , w , c = a . shape rows = int ( np . sqrt ( n )) cols = int ( np . ceil ( float ( n ) / rows )) new_a = np . zeros (( h * rows , w * cols , c )) for i , x in enumerate ( a ): row = i // cols col = i % cols new_a [ row * h :( row + 1 ) * h , col * w :( col + 1 ) * w ] = x return np . squeeze ( new_a ) Visualizer \u00b6 Visualizes attributions directly as a color image. Intended particularly for use with input-attributions. This can also be used for viewing images (rather than attributions). __call__ ( self , attributions , output_file = None , imshow = True , fig = None , return_tiled = False , combine_channels = None , normalization_type = None , blur = None , cmap = None ) special \u00b6 Visualizes the given attributions. Parameters: Name Type Description Default attributions A np.ndarray containing the attributions to be visualized. required output_file File name to save the visualization image to. If None , no image will be saved, but the figure can still be displayed. None imshow If true, a the visualization will be displayed. Otherwise the figure will not be displayed, but the figure can still be saved. True fig The pyplot figure to display the visualization in. If None , a new figure will be created. None return_tiled If true, the returned array will be in the same shape as the visualization, with no batch dimension and the samples in the batch tiled along the width and height dimensions. If false, the returned array will be reshaped to match attributions . False combine_channels If True , the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If None , defaults to the value supplied to the constructor. None normalization_type Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): 'unsigned_max' : normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. 'unsigned_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'magnitude_max' : takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. 'magnitude_sum' : takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. 'signed_max' : normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. 'signed_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'signed_sum' : scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. '01' : normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. 'unnormalized' : leaves the attributions unaffected. If None , defaults to the value supplied to the constructor. None blur Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If None , defaults to the value supplied to the constructor. None cmap matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If None , defaults to the value supplied to the constructor. None Returns: Type Description A np.ndarray array of the numerical representation of the attributions as modified for the visualization. This includes normalization, blurring, etc. Source code in trulens/visualizations.py def __call__ ( self , attributions , output_file = None , imshow = True , fig = None , return_tiled = False , combine_channels = None , normalization_type = None , blur = None , cmap = None ): \"\"\" Visualizes the given attributions. Parameters: attributions: A `np.ndarray` containing the attributions to be visualized. output_file: File name to save the visualization image to. If `None`, no image will be saved, but the figure can still be displayed. imshow: If true, a the visualization will be displayed. Otherwise the figure will not be displayed, but the figure can still be saved. fig: The `pyplot` figure to display the visualization in. If `None`, a new figure will be created. return_tiled: If true, the returned array will be in the same shape as the visualization, with no batch dimension and the samples in the batch tiled along the width and height dimensions. If false, the returned array will be reshaped to match `attributions`. combine_channels: If `True`, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If `None`, defaults to the value supplied to the constructor. normalization_type: Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): - `'unsigned_max'`: normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. - `'unsigned_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'magnitude_max'`: takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. - `'magnitude_sum'`: takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. - `'signed_max'`: normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. - `'signed_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'signed_sum'`: scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. - `'01'`: normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. - `'unnormalized'`: leaves the attributions unaffected. If `None`, defaults to the value supplied to the constructor. blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If `None`, defaults to the value supplied to the constructor. cmap: matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If `None`, defaults to the value supplied to the constructor. Returns: A `np.ndarray` array of the numerical representation of the attributions as modified for the visualization. This includes normalization, blurring, etc. \"\"\" combine_channels , normalization_type , blur , cmap = self . _check_args ( attributions , combine_channels , normalization_type , blur , cmap ) # Combine the channels if specified. if combine_channels : attributions = attributions . mean ( axis = get_backend () . channel_axis , keepdims = True ) # Blur the attributions so the explanation is smoother. if blur : attributions = self . _blur ( attributions , blur ) # Normalize the attributions. attributions = self . _normalize ( attributions , normalization_type ) tiled_attributions = self . tiler . tile ( attributions ) # Display the figure: _fig = plt . figure () if fig is None else fig plt . axis ( 'off' ) plt . imshow ( tiled_attributions , cmap = cmap ) if output_file : plt . savefig ( output_file , bbox_inches = 0 ) if imshow : plt . show () elif fig is None : plt . close ( _fig ) return tiled_attributions if return_tiled else attributions __init__ ( self , combine_channels = False , normalization_type = None , blur = 0.0 , cmap = None ) special \u00b6 Configures the default parameters for the __call__ method (these can be overridden by passing in values to __call__ ). Parameters: Name Type Description Default combine_channels bool If True , the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. False normalization_type str Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): 'unsigned_max' : normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. 'unsigned_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'magnitude_max' : takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. 'magnitude_sum' : takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. 'signed_max' : normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. 'signed_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'signed_sum' : scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. '01' : normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. 'unnormalized' : leaves the attributions unaffected. If None , either 'unsigned_max' (for single-channel data) or 'unsigned_max_positive_centered' (for multi-channel data) is used. None blur float Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. 0.0 cmap Colormap matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If None , the colormap will be chosen based on the normalization type. This argument is only used for single-channel data (including when combine_channels is True). None Source code in trulens/visualizations.py def __init__ ( self , combine_channels : bool = False , normalization_type : str = None , blur : float = 0. , cmap : Colormap = None ): \"\"\" Configures the default parameters for the `__call__` method (these can be overridden by passing in values to `__call__`). Parameters: combine_channels: If `True`, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. normalization_type: Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): - `'unsigned_max'`: normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. - `'unsigned_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'magnitude_max'`: takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. - `'magnitude_sum'`: takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. - `'signed_max'`: normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. - `'signed_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'signed_sum'`: scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. - `'01'`: normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. - `'unnormalized'`: leaves the attributions unaffected. If `None`, either `'unsigned_max'` (for single-channel data) or `'unsigned_max_positive_centered'` (for multi-channel data) is used. blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. cmap: matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If `None`, the colormap will be chosen based on the normalization type. This argument is only used for single-channel data (including when `combine_channels` is True). \"\"\" self . default_combine_channels = combine_channels self . default_normalization_type = normalization_type self . default_blur = blur self . default_cmap = cmap if cmap is not None else self . _get_hotcold () # TODO(klas): in the future we can allow configuring of tiling settings # by allowing the user to specify the tiler. self . tiler = Tiler ()","title":"Visualizations"},{"location":"api/visualizations/#visualization-methods","text":"","title":"Visualization Methods"},{"location":"api/visualizations/#trulens.visualizations","text":"One clear use case for measuring attributions is for human consumption. In order to be fully leveraged by humans, explanations need to be interpretable \u2014 a large vector of numbers doesn\u2019t in general make us more confident we understand what a network is doing. We therefore view an explanation as comprised of both an attribution measurement and an interpretation of what the attribution values represent. One obvious way to interpret attributions, particularly in the image domain, is via visualization. This module provides several visualization methods for interpreting attributions as images.","title":"trulens.visualizations"},{"location":"api/visualizations/#trulens.visualizations.ChannelMaskVisualizer","text":"Uses internal influence to visualize the pixels that are most salient towards a particular internal channel or neuron.","title":"ChannelMaskVisualizer"},{"location":"api/visualizations/#trulens.visualizations.ChannelMaskVisualizer.__call__","text":"Visualizes the given attributions by overlaying an attribution heatmap over the given image.","title":"__call__()"},{"location":"api/visualizations/#parameters","text":"attributions : numpy.ndarray The attributions to visualize. Expected to be in 4-D image format. x : numpy.ndarray The original image(s) over which the attributions are calculated. Must be the same shape as expected by the model used with this visualizer. x_preprocessed : numpy.ndarray, optional If the model requires a preprocessed input (e.g., with the mean subtracted) that is different from how the image should be visualized, x_preprocessed should be specified. In this case x will be used for visualization, and x_preprocessed will be passed to the model when calculating attributions. Must be the same shape as x . output_file : str, optional If specified, the resulting visualization will be saved to a file with the name given by output_file . blur : float, optional If specified, gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If None, defaults to the value supplied to the constructor. Default None. threshold : float Value in the range [0, 1]. Attribution values at or below the percentile given by threshold will be masked. If None, defaults to the value supplied to the constructor. Default None. float Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. Default 0.2. If None, defaults to the value supplied to the constructor. Default None. combine_channels : bool If True, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If None, defaults to the value supplied to the constructor. Default None. Source code in trulens/visualizations.py def __call__ ( self , x , x_preprocessed = None , output_file = None , blur = None , threshold = None , masked_opacity = None , combine_channels = None ): \"\"\" Visualizes the given attributions by overlaying an attribution heatmap over the given image. Parameters ---------- attributions : numpy.ndarray The attributions to visualize. Expected to be in 4-D image format. x : numpy.ndarray The original image(s) over which the attributions are calculated. Must be the same shape as expected by the model used with this visualizer. x_preprocessed : numpy.ndarray, optional If the model requires a preprocessed input (e.g., with the mean subtracted) that is different from how the image should be visualized, ``x_preprocessed`` should be specified. In this case ``x`` will be used for visualization, and ``x_preprocessed`` will be passed to the model when calculating attributions. Must be the same shape as ``x``. output_file : str, optional If specified, the resulting visualization will be saved to a file with the name given by ``output_file``. blur : float, optional If specified, gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If None, defaults to the value supplied to the constructor. Default None. threshold : float Value in the range [0, 1]. Attribution values at or below the percentile given by ``threshold`` will be masked. If None, defaults to the value supplied to the constructor. Default None. masked_opacity: float Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. Default 0.2. If None, defaults to the value supplied to the constructor. Default None. combine_channels : bool If True, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If None, defaults to the value supplied to the constructor. Default None. \"\"\" attrs_input = self . infl_input . attributions ( x if x_preprocessed is None else x_preprocessed ) return self . mask_visualizer ( attrs_input , x , output_file , blur , threshold , masked_opacity , combine_channels )","title":"Parameters"},{"location":"api/visualizations/#trulens.visualizations.ChannelMaskVisualizer.__init__","text":"Configures the default parameters for the __call__ method (these can be overridden by passing in values to __call__ ). Parameters: Name Type Description Default model The wrapped model whose channel we're visualizing. required layer The identifier (either index or name) of the layer in which the channel we're visualizing resides. required channel Index of the channel (for convolutional layers) or internal neuron (for fully-connected layers) that we'd like to visualize. required channel_axis If different from the channel axis specified by the backend, the supplied channel_axis will be used if operating on a convolutional layer with 4-D image format. None agg_fn Function with which to aggregate the remaining dimensions (except the batch dimension) in order to get a single scalar value for each channel; If None , a sum over each neuron in the channel will be taken. This argument is not used when the channels are scalars, e.g., for dense layers. None doi The distribution of interest to use when computing the input attributions towards the specified channel. If None , PointDoI will be used. None blur Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. None threshold Value in the range [0, 1]. Attribution values at or below the percentile given by threshold (after normalization, blurring, etc.) will be masked. 0.5 masked_opacity Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. 0.2 combine_channels If True , the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. True use_attr_as_opacity If True , instead of using threshold and masked_opacity , the opacity of each pixel is given by the 0-1-normalized attribution value. None positive_only If True , only pixels with positive attribution will be unmasked (or given nonzero opacity when use_attr_as_opacity is true). None Source code in trulens/visualizations.py def __init__ ( self , model , layer , channel , channel_axis = None , agg_fn = None , doi = None , blur = None , threshold = 0.5 , masked_opacity = 0.2 , combine_channels = True , use_attr_as_opacity = None , positive_only = None ): \"\"\" Configures the default parameters for the `__call__` method (these can be overridden by passing in values to `__call__`). Parameters: model: The wrapped model whose channel we're visualizing. layer: The identifier (either index or name) of the layer in which the channel we're visualizing resides. channel: Index of the channel (for convolutional layers) or internal neuron (for fully-connected layers) that we'd like to visualize. channel_axis: If different from the channel axis specified by the backend, the supplied `channel_axis` will be used if operating on a convolutional layer with 4-D image format. agg_fn: Function with which to aggregate the remaining dimensions (except the batch dimension) in order to get a single scalar value for each channel; If `None`, a sum over each neuron in the channel will be taken. This argument is not used when the channels are scalars, e.g., for dense layers. doi: The distribution of interest to use when computing the input attributions towards the specified channel. If `None`, `PointDoI` will be used. blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. threshold: Value in the range [0, 1]. Attribution values at or below the percentile given by `threshold` (after normalization, blurring, etc.) will be masked. masked_opacity: Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. combine_channels: If `True`, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. use_attr_as_opacity: If `True`, instead of using `threshold` and `masked_opacity`, the opacity of each pixel is given by the 0-1-normalized attribution value. positive_only: If `True`, only pixels with positive attribution will be unmasked (or given nonzero opacity when `use_attr_as_opacity` is true). \"\"\" B = get_backend () if ( B is not None and ( channel_axis is None or channel_axis < 0 )): channel_axis = B . channel_axis elif ( channel_axis is None or channel_axis < 0 ): channel_axis = 1 self . mask_visualizer = MaskVisualizer ( blur , threshold , masked_opacity , combine_channels , use_attr_as_opacity , positive_only ) self . infl_input = InternalInfluence ( model , ( InputCut (), Cut ( layer )), InternalChannelQoI ( channel , channel_axis , agg_fn ), PointDoi () if doi is None else doi )","title":"__init__()"},{"location":"api/visualizations/#trulens.visualizations.HeatmapVisualizer","text":"Visualizes attributions by overlaying an attribution heatmap over the original image, similar to how GradCAM visualizes attributions.","title":"HeatmapVisualizer"},{"location":"api/visualizations/#trulens.visualizations.HeatmapVisualizer.__call__","text":"Visualizes the given attributions by overlaying an attribution heatmap over the given image. Parameters: Name Type Description Default attributions A np.ndarray containing the attributions to be visualized. required x A np.ndarray of items in the same shape as attributions corresponding to the records explained by the given attributions. The visualization will be superimposed onto the corresponding set of records. required output_file File name to save the visualization image to. If None , no image will be saved, but the figure can still be displayed. None imshow If true, a the visualization will be displayed. Otherwise the figure will not be displayed, but the figure can still be saved. True fig The pyplot figure to display the visualization in. If None , a new figure will be created. None return_tiled If true, the returned array will be in the same shape as the visualization, with no batch dimension and the samples in the batch tiled along the width and height dimensions. If false, the returned array will be reshaped to match attributions . False overlay_opacity float Value in the range [0, 1] specifying the opacity for the heatmap overlay. If None , defaults to the value supplied to the constructor. None combine_channels If True , the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If None , defaults to the value supplied to the constructor. required normalization_type Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): 'unsigned_max' : normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. 'unsigned_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'magnitude_max' : takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. 'magnitude_sum' : takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. 'signed_max' : normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. 'signed_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'signed_sum' : scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. '01' : normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. 'unnormalized' : leaves the attributions unaffected. If None , defaults to the value supplied to the constructor. None blur Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If None , defaults to the value supplied to the constructor. None cmap matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If None , defaults to the value supplied to the constructor. None Returns: Type Description A np.ndarray array of the numerical representation of the attributions as modified for the visualization. This includes normalization, blurring, etc. Source code in trulens/visualizations.py def __call__ ( self , attributions , x , output_file = None , imshow = True , fig = None , return_tiled = False , overlay_opacity = None , normalization_type = None , blur = None , cmap = None ): \"\"\" Visualizes the given attributions by overlaying an attribution heatmap over the given image. Parameters: attributions: A `np.ndarray` containing the attributions to be visualized. x: A `np.ndarray` of items in the same shape as `attributions` corresponding to the records explained by the given attributions. The visualization will be superimposed onto the corresponding set of records. output_file: File name to save the visualization image to. If `None`, no image will be saved, but the figure can still be displayed. imshow: If true, a the visualization will be displayed. Otherwise the figure will not be displayed, but the figure can still be saved. fig: The `pyplot` figure to display the visualization in. If `None`, a new figure will be created. return_tiled: If true, the returned array will be in the same shape as the visualization, with no batch dimension and the samples in the batch tiled along the width and height dimensions. If false, the returned array will be reshaped to match `attributions`. overlay_opacity: float Value in the range [0, 1] specifying the opacity for the heatmap overlay. If `None`, defaults to the value supplied to the constructor. combine_channels: If `True`, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If `None`, defaults to the value supplied to the constructor. normalization_type: Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): - `'unsigned_max'`: normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. - `'unsigned_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'magnitude_max'`: takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. - `'magnitude_sum'`: takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. - `'signed_max'`: normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. - `'signed_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'signed_sum'`: scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. - `'01'`: normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. - `'unnormalized'`: leaves the attributions unaffected. If `None`, defaults to the value supplied to the constructor. blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If `None`, defaults to the value supplied to the constructor. cmap: matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If `None`, defaults to the value supplied to the constructor. Returns: A `np.ndarray` array of the numerical representation of the attributions as modified for the visualization. This includes normalization, blurring, etc. \"\"\" _ , normalization_type , blur , cmap = self . _check_args ( attributions , None , normalization_type , blur , cmap ) # Combine the channels. attributions = attributions . mean ( axis = get_backend () . channel_axis , keepdims = True ) # Blur the attributions so the explanation is smoother. if blur : attributions = self . _blur ( attributions , blur ) # Normalize the attributions. attributions = self . _normalize ( attributions , normalization_type ) tiled_attributions = self . tiler . tile ( attributions ) # Normalize the pixels to be in the range [0, 1]. x = self . _normalize ( x , '01' ) tiled_x = self . tiler . tile ( x ) if cmap is None : cmap = self . default_cmap if overlay_opacity is None : overlay_opacity = self . default_overlay_opacity # Display the figure: _fig = plt . figure () if fig is None else fig plt . axis ( 'off' ) plt . imshow ( tiled_x ) plt . imshow ( tiled_attributions , alpha = overlay_opacity , cmap = cmap ) if output_file : plt . savefig ( output_file , bbox_inches = 0 ) if imshow : plt . show () elif fig is None : plt . close ( _fig ) return tiled_attributions if return_tiled else attributions","title":"__call__()"},{"location":"api/visualizations/#trulens.visualizations.HeatmapVisualizer.__init__","text":"Configures the default parameters for the __call__ method (these can be overridden by passing in values to __call__ ). Parameters: Name Type Description Default overlay_opacity float Value in the range [0, 1] specifying the opacity for the heatmap overlay. 0.5 normalization_type Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): 'unsigned_max' : normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. 'unsigned_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'magnitude_max' : takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. 'magnitude_sum' : takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. 'signed_max' : normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. 'signed_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'signed_sum' : scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. '01' : normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. 'unnormalized' : leaves the attributions unaffected. If None , either 'unsigned_max' (for single-channel data) or 'unsigned_max_positive_centered' (for multi-channel data) is used. None blur Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. 10.0 cmap matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If None , the colormap will be chosen based on the normalization type. This argument is only used for single-channel data (including when combine_channels is True). 'jet' Source code in trulens/visualizations.py def __init__ ( self , overlay_opacity = 0.5 , normalization_type = None , blur = 10. , cmap = 'jet' ): \"\"\" Configures the default parameters for the `__call__` method (these can be overridden by passing in values to `__call__`). Parameters: overlay_opacity: float Value in the range [0, 1] specifying the opacity for the heatmap overlay. normalization_type: Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): - `'unsigned_max'`: normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. - `'unsigned_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'magnitude_max'`: takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. - `'magnitude_sum'`: takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. - `'signed_max'`: normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. - `'signed_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'signed_sum'`: scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. - `'01'`: normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. - `'unnormalized'`: leaves the attributions unaffected. If `None`, either `'unsigned_max'` (for single-channel data) or `'unsigned_max_positive_centered'` (for multi-channel data) is used. blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. cmap: matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If `None`, the colormap will be chosen based on the normalization type. This argument is only used for single-channel data (including when `combine_channels` is True). \"\"\" super () . __init__ ( combine_channels = True , normalization_type = normalization_type , blur = blur , cmap = cmap ) self . default_overlay_opacity = overlay_opacity","title":"__init__()"},{"location":"api/visualizations/#trulens.visualizations.MaskVisualizer","text":"Visualizes attributions by masking the original image to highlight the regions with influence above a given threshold percentile. Intended particularly for use with input-attributions.","title":"MaskVisualizer"},{"location":"api/visualizations/#trulens.visualizations.MaskVisualizer.__init__","text":"Configures the default parameters for the __call__ method (these can be overridden by passing in values to __call__ ). Parameters: Name Type Description Default blur Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. 5.0 threshold Value in the range [0, 1]. Attribution values at or below the percentile given by threshold (after normalization, blurring, etc.) will be masked. 0.5 masked_opacity Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. 0.2 combine_channels If True , the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. True use_attr_as_opacity If True , instead of using threshold and masked_opacity , the opacity of each pixel is given by the 0-1-normalized attribution value. False positive_only If True , only pixels with positive attribution will be unmasked (or given nonzero opacity when use_attr_as_opacity is true). True Source code in trulens/visualizations.py def __init__ ( self , blur = 5. , threshold = 0.5 , masked_opacity = 0.2 , combine_channels = True , use_attr_as_opacity = False , positive_only = True ): \"\"\" Configures the default parameters for the `__call__` method (these can be overridden by passing in values to `__call__`). Parameters: blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. threshold: Value in the range [0, 1]. Attribution values at or below the percentile given by `threshold` (after normalization, blurring, etc.) will be masked. masked_opacity: Value in the range [0, 1] specifying the opacity for the parts of the image that are masked. combine_channels: If `True`, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. use_attr_as_opacity: If `True`, instead of using `threshold` and `masked_opacity`, the opacity of each pixel is given by the 0-1-normalized attribution value. positive_only: If `True`, only pixels with positive attribution will be unmasked (or given nonzero opacity when `use_attr_as_opacity` is true). \"\"\" self . default_blur = blur self . default_thresh = threshold self . default_masked_opacity = masked_opacity self . default_combine_channels = combine_channels # TODO(klas): in the future we can allow configuring of tiling settings # by allowing the user to specify the tiler. self . tiler = Tiler ()","title":"__init__()"},{"location":"api/visualizations/#trulens.visualizations.Tiler","text":"Used to tile batched images or attributions.","title":"Tiler"},{"location":"api/visualizations/#trulens.visualizations.Tiler.tile","text":"Tiles the given array into a grid that is as square as possible. Parameters: Name Type Description Default a ndarray An array of 4D batched image data. required Returns: Type Description ndarray A tiled array of the images from a . The resulting array has rank 3 for color images, and 2 for grayscale images (the batch dimension is removed, as well as the channel dimension for grayscale images). The resulting array has its color channel dimension ordered last to fit the requirements of the matplotlib library. Source code in trulens/visualizations.py def tile ( self , a : np . ndarray ) -> np . ndarray : \"\"\" Tiles the given array into a grid that is as square as possible. Parameters: a: An array of 4D batched image data. Returns: A tiled array of the images from `a`. The resulting array has rank 3 for color images, and 2 for grayscale images (the batch dimension is removed, as well as the channel dimension for grayscale images). The resulting array has its color channel dimension ordered last to fit the requirements of the `matplotlib` library. \"\"\" # `pyplot` expects the channels to come last. if get_backend () . dim_order == 'channels_first' : a = a . transpose (( 0 , 2 , 3 , 1 )) n , h , w , c = a . shape rows = int ( np . sqrt ( n )) cols = int ( np . ceil ( float ( n ) / rows )) new_a = np . zeros (( h * rows , w * cols , c )) for i , x in enumerate ( a ): row = i // cols col = i % cols new_a [ row * h :( row + 1 ) * h , col * w :( col + 1 ) * w ] = x return np . squeeze ( new_a )","title":"tile()"},{"location":"api/visualizations/#trulens.visualizations.Visualizer","text":"Visualizes attributions directly as a color image. Intended particularly for use with input-attributions. This can also be used for viewing images (rather than attributions).","title":"Visualizer"},{"location":"api/visualizations/#trulens.visualizations.Visualizer.__call__","text":"Visualizes the given attributions. Parameters: Name Type Description Default attributions A np.ndarray containing the attributions to be visualized. required output_file File name to save the visualization image to. If None , no image will be saved, but the figure can still be displayed. None imshow If true, a the visualization will be displayed. Otherwise the figure will not be displayed, but the figure can still be saved. True fig The pyplot figure to display the visualization in. If None , a new figure will be created. None return_tiled If true, the returned array will be in the same shape as the visualization, with no batch dimension and the samples in the batch tiled along the width and height dimensions. If false, the returned array will be reshaped to match attributions . False combine_channels If True , the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If None , defaults to the value supplied to the constructor. None normalization_type Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): 'unsigned_max' : normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. 'unsigned_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'magnitude_max' : takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. 'magnitude_sum' : takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. 'signed_max' : normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. 'signed_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'signed_sum' : scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. '01' : normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. 'unnormalized' : leaves the attributions unaffected. If None , defaults to the value supplied to the constructor. None blur Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If None , defaults to the value supplied to the constructor. None cmap matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If None , defaults to the value supplied to the constructor. None Returns: Type Description A np.ndarray array of the numerical representation of the attributions as modified for the visualization. This includes normalization, blurring, etc. Source code in trulens/visualizations.py def __call__ ( self , attributions , output_file = None , imshow = True , fig = None , return_tiled = False , combine_channels = None , normalization_type = None , blur = None , cmap = None ): \"\"\" Visualizes the given attributions. Parameters: attributions: A `np.ndarray` containing the attributions to be visualized. output_file: File name to save the visualization image to. If `None`, no image will be saved, but the figure can still be displayed. imshow: If true, a the visualization will be displayed. Otherwise the figure will not be displayed, but the figure can still be saved. fig: The `pyplot` figure to display the visualization in. If `None`, a new figure will be created. return_tiled: If true, the returned array will be in the same shape as the visualization, with no batch dimension and the samples in the batch tiled along the width and height dimensions. If false, the returned array will be reshaped to match `attributions`. combine_channels: If `True`, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. If `None`, defaults to the value supplied to the constructor. normalization_type: Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): - `'unsigned_max'`: normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. - `'unsigned_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'magnitude_max'`: takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. - `'magnitude_sum'`: takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. - `'signed_max'`: normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. - `'signed_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'signed_sum'`: scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. - `'01'`: normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. - `'unnormalized'`: leaves the attributions unaffected. If `None`, defaults to the value supplied to the constructor. blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. If `None`, defaults to the value supplied to the constructor. cmap: matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If `None`, defaults to the value supplied to the constructor. Returns: A `np.ndarray` array of the numerical representation of the attributions as modified for the visualization. This includes normalization, blurring, etc. \"\"\" combine_channels , normalization_type , blur , cmap = self . _check_args ( attributions , combine_channels , normalization_type , blur , cmap ) # Combine the channels if specified. if combine_channels : attributions = attributions . mean ( axis = get_backend () . channel_axis , keepdims = True ) # Blur the attributions so the explanation is smoother. if blur : attributions = self . _blur ( attributions , blur ) # Normalize the attributions. attributions = self . _normalize ( attributions , normalization_type ) tiled_attributions = self . tiler . tile ( attributions ) # Display the figure: _fig = plt . figure () if fig is None else fig plt . axis ( 'off' ) plt . imshow ( tiled_attributions , cmap = cmap ) if output_file : plt . savefig ( output_file , bbox_inches = 0 ) if imshow : plt . show () elif fig is None : plt . close ( _fig ) return tiled_attributions if return_tiled else attributions","title":"__call__()"},{"location":"api/visualizations/#trulens.visualizations.Visualizer.__init__","text":"Configures the default parameters for the __call__ method (these can be overridden by passing in values to __call__ ). Parameters: Name Type Description Default combine_channels bool If True , the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. False normalization_type str Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): 'unsigned_max' : normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. 'unsigned_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'magnitude_max' : takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. 'magnitude_sum' : takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. 'signed_max' : normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. 'signed_max_positive_centered' : same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. 'signed_sum' : scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. '01' : normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. 'unnormalized' : leaves the attributions unaffected. If None , either 'unsigned_max' (for single-channel data) or 'unsigned_max_positive_centered' (for multi-channel data) is used. None blur float Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. 0.0 cmap Colormap matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If None , the colormap will be chosen based on the normalization type. This argument is only used for single-channel data (including when combine_channels is True). None Source code in trulens/visualizations.py def __init__ ( self , combine_channels : bool = False , normalization_type : str = None , blur : float = 0. , cmap : Colormap = None ): \"\"\" Configures the default parameters for the `__call__` method (these can be overridden by passing in values to `__call__`). Parameters: combine_channels: If `True`, the attributions will be averaged across the channel dimension, resulting in a 1-channel attribution map. normalization_type: Specifies one of the following configurations for normalizing the attributions (each item is normalized separately): - `'unsigned_max'`: normalizes the attributions to the range [-1, 1] by dividing the attributions by the maximum absolute attribution value. - `'unsigned_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'magnitude_max'`: takes the absolute value of the attributions, then normalizes the attributions to the range [0, 1] by dividing by the maximum absolute attribution value. - `'magnitude_sum'`: takes the absolute value of the attributions, then scales them such that they sum to 1. If this option is used, each channel is normalized separately, such that each channel sums to 1. - `'signed_max'`: normalizes the attributions to the range [-1, 1] by dividing the positive values by the maximum positive attribution value and the negative values by the minimum negative attribution value. - `'signed_max_positive_centered'`: same as above, but scales the values to the range [0, 1], with negative scores less than 0.5 and positive scores greater than 0.5. - `'signed_sum'`: scales the positive attributions such that they sum to 1 and the negative attributions such that they scale to -1. If this option is used, each channel is normalized separately. - `'01'`: normalizes the attributions to the range [0, 1] by subtracting the minimum attribution value then dividing by the maximum attribution value. - `'unnormalized'`: leaves the attributions unaffected. If `None`, either `'unsigned_max'` (for single-channel data) or `'unsigned_max_positive_centered'` (for multi-channel data) is used. blur: Gives the radius of a Gaussian blur to be applied to the attributions before visualizing. This can be used to help focus on salient regions rather than specific salient pixels. cmap: matplotlib.colors.Colormap | str, optional Colormap or name of a Colormap to use for the visualization. If `None`, the colormap will be chosen based on the normalization type. This argument is only used for single-channel data (including when `combine_channels` is True). \"\"\" self . default_combine_channels = combine_channels self . default_normalization_type = normalization_type self . default_blur = blur self . default_cmap = cmap if cmap is not None else self . _get_hotcold () # TODO(klas): in the future we can allow configuring of tiling settings # by allowing the user to specify the tiler. self . tiler = Tiler ()","title":"__init__()"}]}