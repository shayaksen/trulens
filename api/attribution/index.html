
<!DOCTYPE html>

<html class="no-js" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<link href="../../img/favicon.ico" rel="icon"/>
<meta content="mkdocs-1.1.2, mkdocs-material-7.2.3" name="generator"/>
<title>Attribution - TruLens</title>
<link href="../../assets/stylesheets/main.f7f47774.min.css" rel="stylesheet"/>
<link href="../../assets/stylesheets/palette.3f5d1f46.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
<link href="../../stylesheets/extra.css" rel="stylesheet"/>
<link href="../../stylesheets/cover.css" rel="stylesheet"/>
</head>
<body data-md-color-accent="" data-md-color-primary="" data-md-color-scheme="trulens" dir="ltr">
<script>function __prefix(e){return new URL("../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#attribution-methods">
          Skip to content
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="Header" class="md-header__inner md-grid">
<a aria-label="TruLens" class="md-header__button md-logo" data-md-component="logo" href="../.." title="TruLens">
<img alt="logo" src="../../img/squid.png"/>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            TruLens
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Attribution
            
          </span>
</div>
</div>
</div>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="Search" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="Search" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"></path></svg>
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"></path></svg>
</label>
<nav aria-label="Search" class="md-search__options">
<button aria-label="Clear" class="md-search__icon md-icon" tabindex="-1" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"></path></svg>
</button>
</nav>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            Initializing search
          </div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Navigation" class="md-nav md-nav--primary" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="TruLens" class="md-nav__button md-logo" data-md-component="logo" href="../.." title="TruLens">
<img alt="logo" src="../../img/squid.png"/>
</a>
    TruLens
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../..">
        Home
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../welcome/">
        Welcome to TruLens!
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../install/">
        Installation
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../quickstart/">
        Quickstart
      </a>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" id="__nav_5" type="checkbox"/>
<label class="md-nav__link" for="__nav_5">
        API Reference
        <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="API Reference" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_5">
<span class="md-nav__icon md-icon"></span>
          API Reference
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" data-md-toggle="toc" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
          Attribution
          <span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="./">
        Attribution
      </a>
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution">
    trulens.nn.attribution
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.AttributionMethod">
    AttributionMethod
  </a>
<nav aria-label="AttributionMethod" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.AttributionMethod.model">
    model
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.AttributionMethod.__init__">
    __init__()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.AttributionMethod.attributions">
    attributions()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.InputAttribution">
    InputAttribution
  </a>
<nav aria-label="InputAttribution" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.InputAttribution.__init__">
    __init__()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.IntegratedGradients">
    IntegratedGradients
  </a>
<nav aria-label="IntegratedGradients" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.IntegratedGradients.__init__">
    __init__()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.InternalInfluence">
    InternalInfluence
  </a>
<nav aria-label="InternalInfluence" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.InternalInfluence.__init__">
    __init__()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.InternalInfluence.attributions">
    attributions()
  </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../model_wrappers/">
        Models
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../slices/">
        Slices
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../quantities/">
        Quantities
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../distributions/">
        Distributions
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../visualizations/">
        Visualizations
      </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution">
    trulens.nn.attribution
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.AttributionMethod">
    AttributionMethod
  </a>
<nav aria-label="AttributionMethod" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.AttributionMethod.model">
    model
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.AttributionMethod.__init__">
    __init__()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.AttributionMethod.attributions">
    attributions()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.InputAttribution">
    InputAttribution
  </a>
<nav aria-label="InputAttribution" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.InputAttribution.__init__">
    __init__()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.IntegratedGradients">
    IntegratedGradients
  </a>
<nav aria-label="IntegratedGradients" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.IntegratedGradients.__init__">
    __init__()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.InternalInfluence">
    InternalInfluence
  </a>
<nav aria-label="InternalInfluence" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.InternalInfluence.__init__">
    __init__()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trulens.nn.attribution.InternalInfluence.attributions">
    attributions()
  </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1 id="attribution-methods">Attribution Methods<a class="headerlink" href="#attribution-methods" title="Permanent link">¶</a></h1>
<div class="doc doc-object doc-module">
<h2 class="hidden-toc" href="#trulens.nn.attribution" id="trulens.nn.attribution" style="visibility: hidden; width: 0; height: 0;">
<a class="headerlink" href="#trulens.nn.attribution" title="Permanent link">¶</a></h2>
<div class="doc doc-contents first">
<p><em>Attribution methods</em> quantitatively measure the contribution of each of a 
function's individual inputs to its output. Gradient-based attribution methods
compute the gradient of a model with respect to its inputs to describe how
important each input is towards the output prediction. These methods can be
applied to assist in explaining deep networks.</p>
<p>TruLens provides implementations of several such techniques, found in this
package.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h2 class="doc doc-heading" id="trulens.nn.attribution.AttributionMethod">
<code>AttributionMethod</code>
<a class="headerlink" href="#trulens.nn.attribution.AttributionMethod" title="Permanent link">¶</a></h2>
<div class="doc doc-contents">
<p>Interface used by all attribution methods.</p>
<p>An attribution method takes a neural network model and provides the ability
to assign values to the variables of the network that specify the importance
of each variable towards particular predictions.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-attribute">
<h3 class="doc doc-heading" id="trulens.nn.attribution.AttributionMethod.model">
<code class="highlight">
model: <span class="n">ModelWrapper</span> </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-property"><code>property</code></small>
<small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
</span>
<a class="headerlink" href="#trulens.nn.attribution.AttributionMethod.model" title="Permanent link">¶</a></h3>
<div class="doc doc-contents">
<p>Model for which attributions are calculated.</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="trulens.nn.attribution.AttributionMethod.__init__">
<code class="highlight language-python">
__init__<span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#trulens.nn.attribution.AttributionMethod.__init__" title="Permanent link">¶</a></h3>
<div class="doc doc-contents">
<p>Abstract constructor.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model</code></td>
<td><code>ModelWrapper</code></td>
<td>
<p>Model for which attributions are calculated.</p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>trulens/nn/attribution.py</code></summary>
<div class="highlight">
<pre><span></span><code><span class="nd">@abstractmethod</span>
<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">ModelWrapper</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Abstract constructor.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        model :</span>
<span class="sd">            Model for which attributions are calculated.</span>
<span class="sd">    """</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="trulens.nn.attribution.AttributionMethod.attributions">
<code class="highlight language-python">
attributions<span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">model_args</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kwargs</span><span class="p">)</span> </code>
<a class="headerlink" href="#trulens.nn.attribution.AttributionMethod.attributions" title="Permanent link">¶</a></h3>
<div class="doc doc-contents">
<p>Returns attributions for the given input. Attributions are in the same shape
as the layer that attributions are being generated for. </p>
<p>The numeric scale of the attributions will depend on the specific implementations 
of the Distribution of Interest and Quantity of Interest. However it is generally 
related to the scale of gradients on the Quantity of Interest. </p>
<p>For example, Integrated Gradients uses the linear interpolation Distribution of Interest
which subsumes the completeness axiom which ensures the sum of all attributions of a record
equals the output determined by the Quantity of Interest on the same record. </p>
<p>The Point Distribution of Interest will be determined by the gradient at a single point,
thus being a good measure of model sensitivity. </p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model_args,</code></td>
<td><code>model_kwargs</code></td>
<td>
<p>The args and kwargs given to the call method of a model.
This should represent the records to obtain attributions for, 
assumed to be a <em>batched</em> input. if <code>self.model</code> supports
evaluation on <em>data tensors</em>, the  appropriate tensor type may
be used (e.g., Pytorch models may accept Pytorch tensors in 
addition to <code>np.ndarray</code>s). The shape of the inputs must match
the input shape of <code>self.model</code>. </p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>An array of attributions, matching the shape and type of <code>from_cut</code>
of the slice. Each entry in the returned array represents the degree
to which the corresponding feature affected the model's outcome on
the corresponding point.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>trulens/nn/attribution.py</code></summary>
<div class="highlight">
<pre><span></span><code><span class="nd">@abstractmethod</span>
<span class="k">def</span> <span class="nf">attributions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">model_args</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kwargs</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Returns attributions for the given input. Attributions are in the same shape</span>
<span class="sd">    as the layer that attributions are being generated for. </span>

<span class="sd">    The numeric scale of the attributions will depend on the specific implementations </span>
<span class="sd">    of the Distribution of Interest and Quantity of Interest. However it is generally </span>
<span class="sd">    related to the scale of gradients on the Quantity of Interest. </span>

<span class="sd">    For example, Integrated Gradients uses the linear interpolation Distribution of Interest</span>
<span class="sd">    which subsumes the completeness axiom which ensures the sum of all attributions of a record</span>
<span class="sd">    equals the output determined by the Quantity of Interest on the same record. </span>

<span class="sd">    The Point Distribution of Interest will be determined by the gradient at a single point,</span>
<span class="sd">    thus being a good measure of model sensitivity. </span>

<span class="sd">    Parameters:</span>
<span class="sd">        model_args, model_kwargs: </span>
<span class="sd">            The args and kwargs given to the call method of a model.</span>
<span class="sd">            This should represent the records to obtain attributions for, </span>
<span class="sd">            assumed to be a *batched* input. if `self.model` supports</span>
<span class="sd">            evaluation on *data tensors*, the  appropriate tensor type may</span>
<span class="sd">            be used (e.g., Pytorch models may accept Pytorch tensors in </span>
<span class="sd">            addition to `np.ndarray`s). The shape of the inputs must match</span>
<span class="sd">            the input shape of `self.model`. </span>

<span class="sd">    Returns:</span>
<span class="sd">        An array of attributions, matching the shape and type of `from_cut`</span>
<span class="sd">        of the slice. Each entry in the returned array represents the degree</span>
<span class="sd">        to which the corresponding feature affected the model's outcome on</span>
<span class="sd">        the corresponding point.</span>
<span class="sd">    """</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h2 class="doc doc-heading" id="trulens.nn.attribution.InputAttribution">
<code>InputAttribution</code>
<a class="headerlink" href="#trulens.nn.attribution.InputAttribution" title="Permanent link">¶</a></h2>
<div class="doc doc-contents">
<p>Attributions of input features on either internal or output quantities. This
is essentially an alias for</p>
<div class="highlight">
<pre><span></span><code><span class="n">InternalInfluence</span><span class="p">(</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="p">(</span><span class="n">trulens</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">slices</span><span class="o">.</span><span class="n">InputCut</span><span class="p">(),</span> <span class="n">cut</span><span class="p">),</span>
    <span class="n">qoi</span><span class="p">,</span>
    <span class="n">doi</span><span class="p">,</span>
    <span class="n">multiply_activation</span><span class="p">)</span>
</code></pre>
</div>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="trulens.nn.attribution.InputAttribution.__init__">
<code class="highlight language-python">
__init__<span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qoi</span><span class="o">=</span><span class="s1">'max'</span><span class="p">,</span> <span class="n">doi</span><span class="o">=</span><span class="s1">'point'</span><span class="p">,</span> <span class="n">multiply_activation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#trulens.nn.attribution.InputAttribution.__init__" title="Permanent link">¶</a></h3>
<div class="doc doc-contents">
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model</code></td>
<td><code>ModelWrapper</code></td>
<td>
<p>Model for which attributions are calculated.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>cut</code></td>
<td><code>Optional[Union[trulens.nn.slices.Cut, int, str]]</code></td>
<td>
<p>The cut determining the layer from which the QoI is derived.
Expects a <code>Cut</code> object, or a related type that can be 
interpreted as a <code>Cut</code>, as documented below.</p>
<p>If an <code>int</code> is given, it represents the index of a layer in 
<code>model</code>. </p>
<p>If a <code>str</code> is given, it represents the name of a layer in 
<code>model</code>. </p>
<p><code>None</code> is an alternative for <code>slices.OutputCut()</code>.</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>qoi</code></td>
<td><code>Union[trulens.nn.quantities.QoI, int, Tuple[int], Callable, str]</code></td>
<td>
<p>quantities.QoI | int | tuple | str
Quantity of interest to attribute. Expects a <code>QoI</code> object, or a
related type that can be interpreted as a <code>QoI</code>, as documented
below.</p>
<p>If an <code>int</code> is given, the quantity of interest is taken to be 
the slice output for the class/neuron/channel specified by the 
given integer, i.e., 
<div class="highlight">
<pre><span></span><code><span class="n">quantities</span><span class="o">.</span><span class="n">InternalChannelQoI</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
</code></pre>
</div>
</p>
<p>If a tuple or list of two integers is given, then the quantity 
of interest is taken to be the comparative quantity for the 
class given by the first integer against the class given by the 
second integer, i.e., 
<div class="highlight">
<pre><span></span><code><span class="n">quantities</span><span class="o">.</span><span class="n">ComparativeQoI</span><span class="p">(</span><span class="o">*</span><span class="n">qoi</span><span class="p">)</span>
</code></pre>
</div>
</p>
<p>If a callable is given, it is interpreted as a function
representing the QoI, i.e.,
<div class="highlight">
<pre><span></span><code><span class="n">quantities</span><span class="o">.</span><span class="n">LambdaQoI</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
</code></pre>
</div>
</p>
<p>If the string, <code>'max'</code>, is given, the quantity of interest is 
taken to be the output for the class with the maximum score, 
i.e., 
<div class="highlight">
<pre><span></span><code><span class="n">quantities</span><span class="o">.</span><span class="n">MaxClassQoI</span><span class="p">()</span>
</code></pre>
</div>
</p>
</td>
<td><code>'max'</code></td>
</tr>
<tr>
<td><code>doi</code></td>
<td><code>Union[trulens.nn.distributions.DoI, str]</code></td>
<td>
<p>distributions.DoI | str
Distribution of interest over inputs. Expects a <code>DoI</code> object, or
a related type that can be interpreted as a <code>DoI</code>, as documented
below.</p>
<p>If the string, <code>'point'</code>, is given, the distribution is taken to
be the single point passed to <code>attributions</code>, i.e., 
<div class="highlight">
<pre><span></span><code><span class="n">distributions</span><span class="o">.</span><span class="n">PointDoi</span><span class="p">()</span>
</code></pre>
</div>
</p>
<p>If the string, <code>'linear'</code>, is given, the distribution is taken 
to be the linear interpolation from the zero input to the point 
passed to <code>attributions</code>, i.e., 
<div class="highlight">
<pre><span></span><code><span class="n">distributions</span><span class="o">.</span><span class="n">LinearDoi</span><span class="p">()</span>
</code></pre>
</div>
</p>
</td>
<td><code>'point'</code></td>
</tr>
<tr>
<td><code>multiply_activation</code></td>
<td><code>bool</code></td>
<td>
<p>bool, optional
Whether to multiply the gradient result by its corresponding
activation, thus converting from "<em>influence space</em>" to 
"<em>attribution space</em>."</p>
</td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>trulens/nn/attribution.py</code></summary>
<div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">ModelWrapper</span><span class="p">,</span>
        <span class="n">cut</span><span class="p">:</span> <span class="n">CutLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">qoi</span><span class="p">:</span> <span class="n">QoiLike</span> <span class="o">=</span> <span class="s1">'max'</span><span class="p">,</span>
        <span class="n">doi</span><span class="p">:</span> <span class="n">DoiLike</span> <span class="o">=</span> <span class="s1">'point'</span><span class="p">,</span>
        <span class="n">multiply_activation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Parameters:</span>
<span class="sd">        model :</span>
<span class="sd">            Model for which attributions are calculated.</span>

<span class="sd">        cut :</span>
<span class="sd">            The cut determining the layer from which the QoI is derived.</span>
<span class="sd">            Expects a `Cut` object, or a related type that can be </span>
<span class="sd">            interpreted as a `Cut`, as documented below.</span>

<span class="sd">            If an `int` is given, it represents the index of a layer in </span>
<span class="sd">            `model`. </span>

<span class="sd">            If a `str` is given, it represents the name of a layer in </span>
<span class="sd">            `model`. </span>

<span class="sd">            `None` is an alternative for `slices.OutputCut()`.</span>

<span class="sd">        qoi : quantities.QoI | int | tuple | str</span>
<span class="sd">            Quantity of interest to attribute. Expects a `QoI` object, or a</span>
<span class="sd">            related type that can be interpreted as a `QoI`, as documented</span>
<span class="sd">            below.</span>

<span class="sd">            If an `int` is given, the quantity of interest is taken to be </span>
<span class="sd">            the slice output for the class/neuron/channel specified by the </span>
<span class="sd">            given integer, i.e., </span>
<span class="sd">            ```python</span>
<span class="sd">            quantities.InternalChannelQoI(qoi)</span>
<span class="sd">            ```</span>

<span class="sd">            If a tuple or list of two integers is given, then the quantity </span>
<span class="sd">            of interest is taken to be the comparative quantity for the </span>
<span class="sd">            class given by the first integer against the class given by the </span>
<span class="sd">            second integer, i.e., </span>
<span class="sd">            ```python</span>
<span class="sd">            quantities.ComparativeQoI(*qoi)</span>
<span class="sd">            ```</span>

<span class="sd">            If a callable is given, it is interpreted as a function</span>
<span class="sd">            representing the QoI, i.e.,</span>
<span class="sd">            ```python</span>
<span class="sd">            quantities.LambdaQoI(qoi)</span>
<span class="sd">            ```</span>

<span class="sd">            If the string, `'max'`, is given, the quantity of interest is </span>
<span class="sd">            taken to be the output for the class with the maximum score, </span>
<span class="sd">            i.e., </span>
<span class="sd">            ```python</span>
<span class="sd">            quantities.MaxClassQoI()</span>
<span class="sd">            ```</span>

<span class="sd">        doi : distributions.DoI | str</span>
<span class="sd">            Distribution of interest over inputs. Expects a `DoI` object, or</span>
<span class="sd">            a related type that can be interpreted as a `DoI`, as documented</span>
<span class="sd">            below.</span>

<span class="sd">            If the string, `'point'`, is given, the distribution is taken to</span>
<span class="sd">            be the single point passed to `attributions`, i.e., </span>
<span class="sd">            ```python</span>
<span class="sd">            distributions.PointDoi()</span>
<span class="sd">            ```</span>

<span class="sd">            If the string, `'linear'`, is given, the distribution is taken </span>
<span class="sd">            to be the linear interpolation from the zero input to the point </span>
<span class="sd">            passed to `attributions`, i.e., </span>
<span class="sd">            ```python</span>
<span class="sd">            distributions.LinearDoi()</span>
<span class="sd">            ```</span>

<span class="sd">        multiply_activation : bool, optional</span>
<span class="sd">            Whether to multiply the gradient result by its corresponding</span>
<span class="sd">            activation, thus converting from "*influence space*" to </span>
<span class="sd">            "*attribution space*."</span>
<span class="sd">    """</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
        <span class="n">model</span><span class="p">,</span> <span class="p">(</span><span class="n">InputCut</span><span class="p">(),</span> <span class="n">cut</span><span class="p">),</span>
        <span class="n">qoi</span><span class="p">,</span>
        <span class="n">doi</span><span class="p">,</span>
        <span class="n">multiply_activation</span><span class="o">=</span><span class="n">multiply_activation</span><span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h2 class="doc doc-heading" id="trulens.nn.attribution.IntegratedGradients">
<code>IntegratedGradients</code>
<a class="headerlink" href="#trulens.nn.attribution.IntegratedGradients" title="Permanent link">¶</a></h2>
<div class="doc doc-contents">
<p>Implementation for the Integrated Gradients method from the following paper:</p>
<p><a href="https://arxiv.org/pdf/1703.01365">Axiomatic Attribution for Deep Networks</a></p>
<p>This should be cited using:</p>
<div class="highlight">
<pre><span></span><code><span class="nc">@INPROCEEDINGS</span><span class="p">{</span>
    <span class="nl">sundararajan17axiomatic</span><span class="p">,</span>
    <span class="na">author</span><span class="p">=</span><span class="s">{Mukund Sundararajan and Ankur Taly, and Qiqi Yan}</span><span class="p">,</span>
    <span class="na">title</span><span class="p">=</span><span class="s">{Axiomatic Attribution for Deep Networks}</span><span class="p">,</span>
    <span class="na">booktitle</span><span class="p">=</span><span class="s">{International Conference on Machine Learning (ICML)}</span><span class="p">,</span>
    <span class="na">year</span><span class="p">=</span><span class="s">{2017}</span><span class="p">,</span>
<span class="p">}</span>
</code></pre>
</div>
<p>This is essentially an alias for</p>
<div class="highlight">
<pre><span></span><code><span class="n">InternalInfluence</span><span class="p">(</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="p">(</span><span class="n">trulens</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">slices</span><span class="o">.</span><span class="n">InputCut</span><span class="p">(),</span> <span class="n">trulens</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">slices</span><span class="o">.</span><span class="n">OutputCut</span><span class="p">()),</span>
    <span class="s1">'max'</span><span class="p">,</span>
    <span class="n">trulens</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">LinearDoi</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">resolution</span><span class="p">),</span>
    <span class="n">multiply_activation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre>
</div>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="trulens.nn.attribution.IntegratedGradients.__init__">
<code class="highlight language-python">
__init__<span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span> </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#trulens.nn.attribution.IntegratedGradients.__init__" title="Permanent link">¶</a></h3>
<div class="doc doc-contents">
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model</code></td>
<td><code>ModelWrapper</code></td>
<td>
<p>Model for which attributions are calculated.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>baseline</code></td>
<td><code></code></td>
<td>
<p>The baseline to interpolate from. Must be same shape as the 
input. If <code>None</code> is given, the zero vector in the appropriate 
shape will be used.</p>
</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>resolution</code></td>
<td><code>int</code></td>
<td>
<p>Number of points to use in the approximation. A higher 
resolution is more computationally expensive, but gives a better
approximation of the mathematical formula this attribution 
method represents.</p>
</td>
<td><code>50</code></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>trulens/nn/attribution.py</code></summary>
<div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">ModelWrapper</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Parameters:</span>
<span class="sd">        model:</span>
<span class="sd">            Model for which attributions are calculated.</span>

<span class="sd">        baseline:</span>
<span class="sd">            The baseline to interpolate from. Must be same shape as the </span>
<span class="sd">            input. If `None` is given, the zero vector in the appropriate </span>
<span class="sd">            shape will be used.</span>

<span class="sd">        resolution:</span>
<span class="sd">            Number of points to use in the approximation. A higher </span>
<span class="sd">            resolution is more computationally expensive, but gives a better</span>
<span class="sd">            approximation of the mathematical formula this attribution </span>
<span class="sd">            method represents.</span>
<span class="sd">    """</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">OutputCut</span><span class="p">(),</span>
        <span class="s1">'max'</span><span class="p">,</span>
        <span class="n">LinearDoi</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">resolution</span><span class="p">),</span>
        <span class="n">multiply_activation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h2 class="doc doc-heading" id="trulens.nn.attribution.InternalInfluence">
<code>InternalInfluence</code>
<a class="headerlink" href="#trulens.nn.attribution.InternalInfluence" title="Permanent link">¶</a></h2>
<div class="doc doc-contents">
<p>Internal attributions parameterized by a slice, quantity of interest, and
distribution of interest.</p>
<p>The <em>slice</em> specifies the layers at which the internals of the model are to
be exposed; it is represented by two <em>cuts</em>, which specify the layer the
attributions are assigned to and the layer from which the quantity of
interest is derived. The <em>Quantity of Interest</em> (QoI) is a function of the
output specified by the slice that determines the network output behavior
that the attributions are to describe. The <em>Distribution of Interest</em> (DoI)
specifies the records over which the attributions are aggregated.</p>
<p>More information can be found in the following paper:</p>
<p><a href="https://arxiv.org/pdf/1802.03788.pdf">Influence-Directed Explanations for Deep Convolutional Networks</a></p>
<p>This should be cited using:</p>
<div class="highlight">
<pre><span></span><code><span class="nc">@INPROCEEDINGS</span><span class="p">{</span>
    <span class="nl">leino18influence</span><span class="p">,</span>
    <span class="na">author</span><span class="p">=</span><span class="s">{</span>
<span class="s">        Klas Leino and</span>
<span class="s">        Shayak Sen and</span>
<span class="s">        Anupam Datta and</span>
<span class="s">        Matt Fredrikson and</span>
<span class="s">        Linyi Li}</span><span class="p">,</span>
    <span class="na">title</span><span class="p">=</span><span class="s">{</span>
<span class="s">        Influence-Directed Explanations</span>
<span class="s">        for Deep Convolutional Networks}</span><span class="p">,</span>
    <span class="na">booktitle</span><span class="p">=</span><span class="s">{IEEE International Test Conference (ITC)}</span><span class="p">,</span>
    <span class="na">year</span><span class="p">=</span><span class="s">{2018}</span><span class="p">,</span>
<span class="p">}</span>
</code></pre>
</div>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="trulens.nn.attribution.InternalInfluence.__init__">
<code class="highlight language-python">
__init__<span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">cuts</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">doi</span><span class="p">,</span> <span class="n">multiply_activation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> </code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
<a class="headerlink" href="#trulens.nn.attribution.InternalInfluence.__init__" title="Permanent link">¶</a></h3>
<div class="doc doc-contents">
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model</code></td>
<td><code>ModelWrapper</code></td>
<td>
<p>Model for which attributions are calculated.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>cuts</code></td>
<td><code>Optional[Union[trulens.nn.slices.Slice, Tuple[Union[trulens.nn.slices.Cut, int, str, NoneType]], trulens.nn.slices.Cut, int, str]]</code></td>
<td>
<p>The slice to use when computing the attributions. The slice 
keeps track of the layer whose output attributions are 
calculated and the layer for which the quantity of interest is 
computed. Expects a <code>Slice</code> object, or a related type that can
be interpreted as a <code>Slice</code>, as documented below.</p>
<p>If a single <code>Cut</code> object is given, it is assumed to be the cut 
representing the layer for which attributions are calculated 
(i.e., <code>from_cut</code> in <code>Slice</code>) and the layer for the quantity of 
interest (i.e., <code>to_cut</code> in <code>slices.Slice</code>) is taken to be the 
output of the network. If a tuple or list of two <code>Cut</code>s is 
given, they are assumed to be <code>from_cut</code> and <code>to_cut</code>, 
respectively.</p>
<p>A cut (or the cuts within the tuple) can also be represented as 
an <code>int</code>, <code>str</code>, or <code>None</code>. If an <code>int</code> is given, it represents 
the index of a layer in <code>model</code>. If a <code>str</code> is given, it 
represents the name of a layer in <code>model</code>. <code>None</code> is an 
alternative for <code>slices.InputCut</code>.</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>qoi</code></td>
<td><code>Union[trulens.nn.quantities.QoI, int, Tuple[int], Callable, str]</code></td>
<td>
<p>Quantity of interest to attribute. Expects a <code>QoI</code> object, or a
related type that can be interpreted as a <code>QoI</code>, as documented
below.</p>
<p>If an <code>int</code> is given, the quantity of interest is taken to be 
the slice output for the class/neuron/channel specified by the 
given integer, i.e., 
<div class="highlight">
<pre><span></span><code><span class="n">quantities</span><span class="o">.</span><span class="n">InternalChannelQoI</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
</code></pre>
</div>
</p>
<p>If a tuple or list of two integers is given, then the quantity 
of interest is taken to be the comparative quantity for the 
class given by the first integer against the class given by the 
second integer, i.e., 
<div class="highlight">
<pre><span></span><code><span class="n">quantities</span><span class="o">.</span><span class="n">ComparativeQoI</span><span class="p">(</span><span class="o">*</span><span class="n">qoi</span><span class="p">)</span>
</code></pre>
</div>
</p>
<p>If a callable is given, it is interpreted as a function
representing the QoI, i.e.,
<div class="highlight">
<pre><span></span><code><span class="n">quantities</span><span class="o">.</span><span class="n">LambdaQoI</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
</code></pre>
</div>
</p>
<p>If the string, <code>'max'</code>, is given, the quantity of interest is 
taken to be the output for the class with the maximum score, 
i.e., 
<div class="highlight">
<pre><span></span><code><span class="n">quantities</span><span class="o">.</span><span class="n">MaxClassQoI</span><span class="p">()</span>
</code></pre>
</div>
</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>doi</code></td>
<td><code>Union[trulens.nn.distributions.DoI, str]</code></td>
<td>
<p>Distribution of interest over inputs. Expects a <code>DoI</code> object, or
a related type that can be interpreted as a <code>DoI</code>, as documented
below.</p>
<p>If the string, <code>'point'</code>, is given, the distribution is taken to
be the single point passed to <code>attributions</code>, i.e., 
<div class="highlight">
<pre><span></span><code><span class="n">distributions</span><span class="o">.</span><span class="n">PointDoi</span><span class="p">()</span>
</code></pre>
</div>
</p>
<p>If the string, <code>'linear'</code>, is given, the distribution is taken 
to be the linear interpolation from the zero input to the point 
passed to <code>attributions</code>, i.e., 
<div class="highlight">
<pre><span></span><code><span class="n">distributions</span><span class="o">.</span><span class="n">LinearDoi</span><span class="p">()</span>
</code></pre>
</div>
</p>
</td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>multiply_activation</code></td>
<td><code>bool</code></td>
<td>
<p>Whether to multiply the gradient result by its corresponding
activation, thus converting from "<em>influence space</em>" to 
"<em>attribution space</em>."</p>
</td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>trulens/nn/attribution.py</code></summary>
<div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">ModelWrapper</span><span class="p">,</span>
        <span class="n">cuts</span><span class="p">:</span> <span class="n">SliceLike</span><span class="p">,</span>
        <span class="n">qoi</span><span class="p">:</span> <span class="n">QoiLike</span><span class="p">,</span>
        <span class="n">doi</span><span class="p">:</span> <span class="n">DoiLike</span><span class="p">,</span>
        <span class="n">multiply_activation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Parameters:</span>
<span class="sd">        model:</span>
<span class="sd">            Model for which attributions are calculated.</span>

<span class="sd">        cuts: </span>
<span class="sd">            The slice to use when computing the attributions. The slice </span>
<span class="sd">            keeps track of the layer whose output attributions are </span>
<span class="sd">            calculated and the layer for which the quantity of interest is </span>
<span class="sd">            computed. Expects a `Slice` object, or a related type that can</span>
<span class="sd">            be interpreted as a `Slice`, as documented below.</span>

<span class="sd">            If a single `Cut` object is given, it is assumed to be the cut </span>
<span class="sd">            representing the layer for which attributions are calculated </span>
<span class="sd">            (i.e., `from_cut` in `Slice`) and the layer for the quantity of </span>
<span class="sd">            interest (i.e., `to_cut` in `slices.Slice`) is taken to be the </span>
<span class="sd">            output of the network. If a tuple or list of two `Cut`s is </span>
<span class="sd">            given, they are assumed to be `from_cut` and `to_cut`, </span>
<span class="sd">            respectively.</span>

<span class="sd">            A cut (or the cuts within the tuple) can also be represented as </span>
<span class="sd">            an `int`, `str`, or `None`. If an `int` is given, it represents </span>
<span class="sd">            the index of a layer in `model`. If a `str` is given, it </span>
<span class="sd">            represents the name of a layer in `model`. `None` is an </span>
<span class="sd">            alternative for `slices.InputCut`.</span>

<span class="sd">        qoi:</span>
<span class="sd">            Quantity of interest to attribute. Expects a `QoI` object, or a</span>
<span class="sd">            related type that can be interpreted as a `QoI`, as documented</span>
<span class="sd">            below.</span>

<span class="sd">            If an `int` is given, the quantity of interest is taken to be </span>
<span class="sd">            the slice output for the class/neuron/channel specified by the </span>
<span class="sd">            given integer, i.e., </span>
<span class="sd">            ```python</span>
<span class="sd">            quantities.InternalChannelQoI(qoi)</span>
<span class="sd">            ```</span>

<span class="sd">            If a tuple or list of two integers is given, then the quantity </span>
<span class="sd">            of interest is taken to be the comparative quantity for the </span>
<span class="sd">            class given by the first integer against the class given by the </span>
<span class="sd">            second integer, i.e., </span>
<span class="sd">            ```python</span>
<span class="sd">            quantities.ComparativeQoI(*qoi)</span>
<span class="sd">            ```</span>

<span class="sd">            If a callable is given, it is interpreted as a function</span>
<span class="sd">            representing the QoI, i.e.,</span>
<span class="sd">            ```python</span>
<span class="sd">            quantities.LambdaQoI(qoi)</span>
<span class="sd">            ```</span>

<span class="sd">            If the string, `'max'`, is given, the quantity of interest is </span>
<span class="sd">            taken to be the output for the class with the maximum score, </span>
<span class="sd">            i.e., </span>
<span class="sd">            ```python</span>
<span class="sd">            quantities.MaxClassQoI()</span>
<span class="sd">            ```</span>

<span class="sd">        doi:</span>
<span class="sd">            Distribution of interest over inputs. Expects a `DoI` object, or</span>
<span class="sd">            a related type that can be interpreted as a `DoI`, as documented</span>
<span class="sd">            below.</span>

<span class="sd">            If the string, `'point'`, is given, the distribution is taken to</span>
<span class="sd">            be the single point passed to `attributions`, i.e., </span>
<span class="sd">            ```python</span>
<span class="sd">            distributions.PointDoi()</span>
<span class="sd">            ```</span>

<span class="sd">            If the string, `'linear'`, is given, the distribution is taken </span>
<span class="sd">            to be the linear interpolation from the zero input to the point </span>
<span class="sd">            passed to `attributions`, i.e., </span>
<span class="sd">            ```python</span>
<span class="sd">            distributions.LinearDoi()</span>
<span class="sd">            ```</span>

<span class="sd">        multiply_activation:</span>
<span class="sd">            Whether to multiply the gradient result by its corresponding</span>
<span class="sd">            activation, thus converting from "*influence space*" to </span>
<span class="sd">            "*attribution space*."</span>
<span class="sd">    """</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">slice</span> <span class="o">=</span> <span class="n">InternalInfluence</span><span class="o">.</span><span class="n">__get_slice</span><span class="p">(</span><span class="n">cuts</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="n">InternalInfluence</span><span class="o">.</span><span class="n">__get_qoi</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">doi</span> <span class="o">=</span> <span class="n">InternalInfluence</span><span class="o">.</span><span class="n">__get_doi</span><span class="p">(</span><span class="n">doi</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_do_multiply</span> <span class="o">=</span> <span class="n">multiply_activation</span>
</code></pre>
</div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="trulens.nn.attribution.InternalInfluence.attributions">
<code class="highlight language-python">
attributions<span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">model_args</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kwargs</span><span class="p">)</span> </code>
<a class="headerlink" href="#trulens.nn.attribution.InternalInfluence.attributions" title="Permanent link">¶</a></h3>
<div class="doc doc-contents">
<p>Returns attributions for the given input. Attributions are in the same shape
as the layer that attributions are being generated for. </p>
<p>The numeric scale of the attributions will depend on the specific implementations 
of the Distribution of Interest and Quantity of Interest. However it is generally 
related to the scale of gradients on the Quantity of Interest. </p>
<p>For example, Integrated Gradients uses the linear interpolation Distribution of Interest
which subsumes the completeness axiom which ensures the sum of all attributions of a record
equals the output determined by the Quantity of Interest on the same record. </p>
<p>The Point Distribution of Interest will be determined by the gradient at a single point,
thus being a good measure of model sensitivity. </p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>model_args,</code></td>
<td><code>model_kwargs</code></td>
<td>
<p>The args and kwargs given to the call method of a model.
This should represent the records to obtain attributions for, 
assumed to be a <em>batched</em> input. if <code>self.model</code> supports
evaluation on <em>data tensors</em>, the  appropriate tensor type may
be used (e.g., Pytorch models may accept Pytorch tensors in 
addition to <code>np.ndarray</code>s). The shape of the inputs must match
the input shape of <code>self.model</code>. </p>
</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td>
<p>An array of attributions, matching the shape and type of <code>from_cut</code>
of the slice. Each entry in the returned array represents the degree
to which the corresponding feature affected the model's outcome on
the corresponding point.</p>
</td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>trulens/nn/attribution.py</code></summary>
<div class="highlight">
<pre><span></span><code><span class="k">def</span> <span class="nf">attributions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">model_args</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kwargs</span><span class="p">):</span>
    <span class="n">doi_cut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi</span><span class="o">.</span><span class="n">cut</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi</span><span class="o">.</span><span class="n">cut</span><span class="p">()</span> <span class="k">else</span> <span class="n">InputCut</span><span class="p">()</span>

    <span class="n">doi_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fprop</span><span class="p">(</span><span class="n">model_args</span><span class="p">,</span> <span class="n">model_kwargs</span><span class="p">,</span> <span class="n">to_cut</span><span class="o">=</span><span class="n">doi_cut</span><span class="p">)</span>
    <span class="c1"># DoI supports tensor or list of tensor. unwrap args to perform DoI on</span>
    <span class="c1"># top level list</span>

    <span class="c1"># Depending on the model_arg input, the data may be nested in data</span>
    <span class="c1"># containers. We unwrap so that there operations are working on a single</span>
    <span class="c1"># level of data container.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doi_val</span><span class="p">,</span> <span class="n">DATA_CONTAINER_TYPE</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">doi_val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DATA_CONTAINER_TYPE</span><span class="p">):</span>
        <span class="n">doi_val</span> <span class="o">=</span> <span class="n">doi_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doi_val</span><span class="p">,</span> <span class="n">DATA_CONTAINER_TYPE</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">doi_val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">doi_val</span> <span class="o">=</span> <span class="n">doi_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi</span><span class="p">(</span><span class="n">doi_val</span><span class="p">)</span>
    <span class="n">n_doi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">InternalInfluence</span><span class="o">.</span><span class="n">__concatenate_doi</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

    <span class="c1"># Calculate the gradient of each of the points in the DoI.</span>
    <span class="n">qoi_grads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">qoi_bprop</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">,</span>
        <span class="n">model_args</span><span class="p">,</span>
        <span class="n">model_kwargs</span><span class="p">,</span>
        <span class="n">attribution_cut</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">from_cut</span><span class="p">,</span>
        <span class="n">to_cut</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">to_cut</span><span class="p">,</span>
        <span class="n">intervention</span><span class="o">=</span><span class="n">D</span><span class="p">,</span>
        <span class="n">doi_cut</span><span class="o">=</span><span class="n">doi_cut</span><span class="p">)</span>
    <span class="c1"># Take the mean across the samples in the DoI.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qoi_grads</span><span class="p">,</span> <span class="n">DATA_CONTAINER_TYPE</span><span class="p">):</span>
        <span class="n">attributions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">get_backend</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                <span class="n">get_backend</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">qoi_grad</span><span class="p">,</span> <span class="p">(</span><span class="n">n_doi</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">qoi_grad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">qoi_grad</span> <span class="ow">in</span> <span class="n">qoi_grads</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">attributions</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
            <span class="n">get_backend</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">qoi_grads</span><span class="p">,</span> <span class="p">(</span><span class="n">n_doi</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">qoi_grads</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Multiply by the activation multiplier if specified.</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_multiply</span><span class="p">:</span>
        <span class="n">z_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fprop</span><span class="p">(</span>
            <span class="n">model_args</span><span class="p">,</span> <span class="n">model_kwargs</span><span class="p">,</span> <span class="n">to_cut</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">from_cut</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z_val</span><span class="p">,</span> <span class="n">DATA_CONTAINER_TYPE</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">z_val</span> <span class="o">=</span> <span class="n">z_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributions</span><span class="p">,</span> <span class="n">DATA_CONTAINER_TYPE</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">attributions</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z_val</span><span class="p">,</span> <span class="n">DATA_CONTAINER_TYPE</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span>
                        <span class="n">z_val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributions</span><span class="p">):</span>
                    <span class="n">attributions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi</span><span class="o">.</span><span class="n">get_activation_multiplier</span><span class="p">(</span>
                        <span class="n">z_val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">attributions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">doi</span><span class="o">.</span><span class="n">get_activation_multiplier</span><span class="p">(</span><span class="n">z_val</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">attributions</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi</span><span class="o">.</span><span class="n">get_activation_multiplier</span><span class="p">(</span><span class="n">z_val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">attributions</span>
</code></pre>
</div>
</details>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<nav aria-label="Footer" class="md-footer__inner md-grid">
<a aria-label="Previous: Quickstart" class="md-footer__link md-footer__link--prev" href="../../quickstart/" rel="prev">
<div class="md-footer__button md-icon">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"></path></svg>
</div>
<div class="md-footer__title">
<div class="md-ellipsis">
<span class="md-footer__direction">
                Previous
              </span>
              Quickstart
            </div>
</div>
</a>
<a aria-label="Next: Models" class="md-footer__link md-footer__link--next" href="../model_wrappers/" rel="next">
<div class="md-footer__title">
<div class="md-ellipsis">
<span class="md-footer__direction">
                Next
              </span>
              Models
            </div>
</div>
<div class="md-footer__button md-icon">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"></path></svg>
</div>
</a>
</nav>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
          Material for MkDocs
        </a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../assets/javascripts/workers/search.709b4209.min.js", "version": null}</script>
<script src="../../assets/javascripts/bundle.29db7785.min.js"></script>
<script src="../../javascript/config.js"></script>
<script src="../../javascript/app.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script src="../../javascript/tex-mml-chtml-3.0.0.js"></script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</body>
</html>